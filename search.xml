<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络协议学习笔记1：为什么要学习网络协议？]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[会了计算机语言，你就能够教给一台计算机完成你的工作了。但是，要想打造互联网世界的通天塔，只教给一台机器做什么是不够的，你需要学会教给一大片机器做什么。这就需要网络协议。只有通过网络协议，才能使一大片机器互相协作、共同完成一件事。 摘要协议三要素 ：语法、语义、顺序 常用的网络协议 网络数据包结构： Mac头 Ip头 Tcp头 Htt头 数据体一次玄奘西行 为什么要学习网络协议？只有通过网络协议，才能使一大片机器互相协作、共同完成一件事。 协议三要素例如编写代码打印“hello world”也是人类和计算机沟通的协议，需要经过编译成机器可识别文件执行 。不同的计算机之间必须使用相同的网络协议才能进行通信。语法：“如何讲”，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。语义：“讲什么”，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。顺序：“讲啥先”，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值。 比如浏览器上展示网页内容：它之所以能够显示缤纷多彩的页面，是因为它收到了一段来自 HTTP协议的“东西”，例如网易考拉，格式如下： 12345678910HTTP/1.1 200 OKDate: Tue, 27 Mar 2018 16:50:26 GMTContent-Type: text/html;charset=UTF-8Content-Language: zh-CN&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;base href="https://pages.kaola.com/" /&gt;&lt;meta charset="utf-8"/&gt; &lt;title&gt; 网易考拉 3 周年主会场 &lt;/title&gt; 首先，符合语法。只有按照上面那个格式来，浏览器才认。例如，上来是状态，然后是首部，然后是内容。然后，符合语义。就是要按照约定的意思来。例如，状态 200，表述的意思是网页成功返回。如果不成功，就是我们常见的“404”。最后，符合顺序。点击浏览器，就是发送出一个 HTTP 请求，然后才有上面那一串 HTTP 返回的东西。浏览器显然按照协议商定好的做了，最后一个五彩缤纷的页面就出现在你面前了。 常用的网络协议DNS协议、HTTP协议、HTTPS协议、TCP/IP协议、IP协议、DHCP协议、ARP协议**等**比如网上的一次点击购物的请求包含： 图上5层，从下往上一层层封装：第一层：是什么第二层：啥样式 DNS、HTTP、HTTPS 所在的层我们称为应用层。 经过应用层封装后，浏览器会将应用层的包交给下一层去完成，通过socket 编程来实现 第三层：咋处理 传输层有两种协议，一种是无连接的协议UDP（发短信），一种是面向连接的协议TCP（打电话） TCP 协议里面会有两个端口，一个是浏览器监听的端口，一个是电商的服务器监听的端口。操作系统往往通过端口来判断，它得到的包应该给哪个进程。传输层封装完毕后，浏览器会将包交给操作系统的网络层 第四层：交给谁 网络层的协议是 IP 协议。 IP 协议里面会有源 IP 地址，即浏览器所在机器的 IP 地址和目标 IP 地址，也即电商网站所在服务器的 IP 地址。 第五层：先去哪 操作系统根据IP这个门牌号判断是内地人还是外地人的，去外地就要经过网关。 而操作系统启动的时候，就会被 DHCP 协议配置 IP 地址，以及默认的网关的 IP 地址 。 操作系统发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理MAC地址。 于是操作系统将 IP 包交给了下一层，也就是MAC 层。 由于这个包里面是有 MAC 地址的，因而它能够到达网关。 网关往往是一个路由器，到某个 IP 地址应该怎么走，这个叫作路由表。 玄奘西行 一次购物请求的整个过程如同玄奘西行，不断经过国家的城关（路由器）；每个城关连着两个国家（局域网），一旦跨越城关，就需要拿出通关文牒（数据包中包含源IP地址）并询问接下来该如何走，每个城关都知道下一个城关怎么走； 当城关通过通关文牒知道目的地（目标IP）在自己邻接的国家中，就好发起通告（广播）寻找，然后得到回复（目标MAC地址），然后就可以到达天竺（目标服务器）了； 然后天竺确认你确实是找天竺的（在城关寻得的MAC地址对得上），再确认你寻的真经是在天竺的（IP地址对得上），最后让人寻真经给你（IP 头里会写上一层封装的是 TCP 协议，然后将其交给传输层，即TCP层）； 西行路上千难万险，因此到了得报个平安（仅仅是 TCP 层的一个说明，原路返回，如果过段时间还没回复，不断重发，知道平安到达的回复，tcp的三次握手）。 城关： 流程： 有IP地址为什么还需要MAC地址？IP地址可以变动，而MAC地址是唯一的。IP是个人地址，MAC是个人身份证，地址可以变更，但身份证不行。到达了个人地址还需要确认身份证，才能证明找的是本人。 当网络包到达一个城关的时候，可以通过路由表得到下一个城关的 IP 地址，直接通过 IP 地址找就可以了，为什么还要通过本地的 MAC 地址呢？ 局域网内IP地址是动态分配的，假如我是192.168.2.100，如果我下线了，可能IP就分配给了另一台电脑。IP和设备并不总是对应的，这对通信就产生了问题，但是MAC地址不同，MAC地址和设备是一一对应且全球唯一的。所以局域网使用MAC地址通信没有问题。 历史遗留问题：早期的以太网只有交换机，没有路由器，以太网内通过MAC地址通信。后来才有了互联网，为了兼容原本的模式，采用了IP+MAC地址通信的方式。为啥不推到了重来呢？看看IPv6的处境你就知道了。所以是先有MAC地址后有的IP，IP的提出主要还是因为MAC地址本身的缺陷，这个问题换成有了MAC为何还要IP地址也很有意思。 第一：MAC地址本身的缺陷：因为MAC地址是硬件提供商写在网卡中的，MAC地址虽然唯一但是不能表明用户在整个互联网中的位置，除非维护一个超级大MAC地址对应表，那寻址效率肯定爆炸。但是IP地址解决了这个问题，因为IP地址是网络提供商给你的，所以你在哪里整个网络都是知道的。第二：安全问题：获取MAC地址是通过ARP协议来完成的，如果只用MAC地址通信，那么广播风暴是个难题。 猜想：如果哪天每人一个固定的IPv6地址，那么MAC地址+IPv4的模式是不是可以被替换了？ 其实手机通过数据上网就是一个通过类似mac寻址的一个网络。在移动网络中是允许你移动的，这是由于基站会记录你的位置信息。并且核心网与公网的通信是通过ip来实现的，而在手机和基站间的通信是通过类似mac的一个唯一码实现的。并且移动网络整体建设成本比互联网的成本高很多，消费也高很多。 为什么mac地址是全世界唯一的？网卡MAC码是由全球惟一的一个固定组织来分配的，未经认证和授权的厂家无权生产网卡。每块网卡都有一个固定的卡号，并且任何正规厂家生产的网卡上都直接标明了卡号，一般为一组12位的16进制数。其中前6位代表网卡的生产厂商。后面的位数是设备号。当然在操作系统级别改Mac地址又是一种说法。 ————————————————————————————————————————以上笔记学习于“极客时间”APP专栏，部分内容选自专栏评论。]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 简单关键字爬取微信公众号文章]]></title>
    <url>%2F2018%2F06%2F26%2FPython-%E7%AE%80%E5%8D%95%E5%85%B3%E9%94%AE%E5%AD%97%E7%88%AC%E5%8F%96%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[记录一次爬虫作业项目 序爬取目标：微信公众号“纵梦广科”中“表白墙”（可选“吐槽墙”）的文章爬取字段：表白对象、表白内容爬取缘由：分析“表白墙”上的同学什么说得多的词爬取工具：matplotlib、wordcloud、jieba爬取结果: “表白墙”文章160篇爬取收获：简单爬取公众号文章、简单生成词云爬取注意： 因为爬取内容可以简洁地直接保存txt文本进行绘画词云分析，所有并没有存入数据库 本项目代码不具有可复用性，无论是登录的cookie还是文章的页数都需要重新手动获取输入 代码中cookie的值太长了，都在一行不方便阅读，于是做了分行，可以根据个人喜好选择 本代码通用于爬取公众号文章的标题和url，如需要爬取文章内容则需要手动更改爬取规则 token的值是爬取的公众号的标识符，如果更换公众号就需要更改该值 本项目代码因为“表白墙”与“吐槽墙”网页结构相同，因此可以自行选择输入“表白墙”或“吐槽墙”进行爬取 词云图在本文档后面 获取cookie等操作步骤在本文最后 ps:在参考文章中的例子是直接搜索公众号全部内容文章的，我测试过这样爬取全部的话只能爬几页就被提示”操作太频繁“而无法爬取，但换成关键字”query”搜索的话没有出现问题，目前本代码爬取”表白墙“32页并没有本禁止。本来还尝试如何避免封装爬取全部文章但没有成功，但如果关键字是空白符或者其他标点符号的话也能获取大部分文章 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115# -*- coding: utf-8 -*-import requestsfrom PIL import Imagefrom lxml import etreeimport timeimport randomimport matplotlib.pyplot as pltimport numpy as npfrom wordcloud import WordCloudimport jieba# 使用Cookie，跳过登陆操作headers = &#123; "Cookie": "noticeLoginFlag=1; remember_acct=820605644%40qq.com; " "ua_id=F89e6CvMPIib8tkPAAAAAE8A9_O5KrS5oMM390XQRHI=; mm_lang=zh_CN; pgv_pvi=1996118016; " "noticeLoginFlag=1; remember_acct=820605644%40qq.com; pgv_si=s2063726592; ticket_id=gh_86437b3d3630; " "cert=3RRm40LWsECquCbg_jx5lQTMXRR4M0tN; rewardsn=; wxtokenkey=777; " "uuid=652947b257247d453cd64dc13a5daf0b; ticket=d19dbee738a3be7f0806c8a5f726b8d8cac125f6; " "data_bizuin=3555601673; bizuin=3551846274; " "data_ticket=eeN9lRUD61DWiiLZEJyFKGoi70SoJ2dB1BoNi4PnSvNaf6R3jA83ZYyEI1y3LaOU; " "slave_sid" "=elBZTHhvYlc0VmNnYTM0SnZ6Wl9DaGZTNWh0M0VZVHlxUDBfWHNUW" "jFVbEpOcFpmWEpuNUFXTEdGRWI5a3p6OGhrUWYweExnNjN2d0xMUWEwTVlLVWxIWk9mXzhzbkYxWndCQUVYTm" "l1UnVxYlNWbmR3Q09VT2pMbEFMZDNhOFhXTnRnMlpDbDhvYzZWN2hQ;" " slave_user=gh_86437b3d3630; xid=a5467f49610c64af7a7022c6a4596f40; " "openid2ticket_oCS3u05exHidsZqiS_3Q8Yn-YtYI=JjxfUwXvqw0VBHJhW5TvmrOn8W5QMp/ReaanapVptWI=", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) " "Chrome/65.0.3325.162 Safari/537.36",&#125;# 词云def get_word(f): """ 创建词云图片，默认样式 :param f: :return: """ text_from_file_with_apath = open(f, 'rb').read().decode('utf-8') wordlist_after_jieba = jieba.cut(text_from_file_with_apath, cut_all=True) print(wordlist_after_jieba) wl_space_split = " ".join(wordlist_after_jieba) alice_mask = np.array(Image.open("girl.jpg")) # 以数组的形式加载图画 my_wordcloud = WordCloud(font_path="simhei.ttf", # 设置字体 background_color="white", # 背景颜色 max_words=2000, # 词云显示的最大词数 mask=alice_mask, # 设置背景图片 max_font_size=100, # 字体最大值 random_state=42, margin=2, # 设置图片默认的大小,但是如果使用背景图片的话,那么保存的图片大小将会按照其大小保存,margin为词语边缘距离 ).generate(wl_space_split) plt.imshow(my_wordcloud) plt.axis("off") plt.show()def get_info(url): """ 获取文章中的吐槽对象和吐槽内容 :param url: :return: """ res = requests.get(url, headers=headers) selector = etree.HTML(res.text) names = selector.xpath('// *[ @ id = "js_content"] // section / section[2] / section / span / span / text()') contents = selector.xpath('// *[ @ id = "js_content"] // section / section[2] / section / text()') with open('name.txt', 'ab+') as f: for s in names: f.write(s.strip().encode('utf-8')) with open('content.txt', 'ab+') as f: for s in contents: f.write(s.strip().encode('utf-8')) return 'content.txt', 'name.txt'def get_list(url, input_name, post_num): """ 获取每页搜索结果的json中文章的标题和url :param url: :return: """ for num in range(post_num): data = &#123; "token": 1111467131, "lang": "zh_CN", "f": "json", "ajax": "1", "action": "list_ex", "begin": num * 5, "random": 0.040206335386987035, "count": "5", "query": input_name, "fakeid": "MzAwMzExNTQyNQ==", "type": "9", &#125; # 使用get方法进行提交 content_json = requests.get(url, headers=headers, params=data).json() # 返回了一个json，里面是每一页的数据 for item in content_json["app_msg_list"]: # 提取每页文章的标题及对应的url print(item["title"], "url:", item["link"]) f1, f2 = get_info(item["link"]) time.sleep(random.randint(0, 30)) return f1, f2# 目标urlif __name__ == "__main__": input_name = "表白墙" # 表白墙或吐槽墙任选其一 url = "https://mp.weixin.qq.com/cgi-bin/appmsg" f1, f2 = get_list(url, input_name, post_num=32) get_word(f1) # 创建词云 get_word(f2) 图片公众号截图： 表白内容词云： 表白对象词云： 操作步骤1、拥有一个微信个人订阅号，附上登陆和注册链接。微信公众平台 2、好在之前无聊注册过一次，所以就可以直接登陆操作。没有注册的童鞋可以用自己的微信号注册一下，过程十分简单，在此就不赘述了 3、登陆之后，点击左侧菜单栏“管理”-“素材管理”。再点击右边的“新建图文素材” ​弹出一个新的标签页，在上面的工具栏找到“超链接”并点击 弹出了一个小窗口，选择“查找文章”，输入需要查找的公众号点击之后，可以弹出该公众号的所有历史文章关键字搜索、页数 查看cookie 查看token 本文部分参考该博友的文章：https://blog.csdn.net/wnma3mz/article/details/78570580]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 设置首页隐藏指定文章]]></title>
    <url>%2F2018%2F06%2F12%2FHexo-%E8%AE%BE%E7%BD%AE%E9%A6%96%E9%A1%B5%E9%9A%90%E8%97%8F%E6%8C%87%E5%AE%9A%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[有时候我们可能只想在首页显示关于编程之类的内容，而个人日记之类的文章放在其他分类之下而不在首页显示。可以从、分类、标签、归档中查看文章。 自定义front-matter的参数例如，自定义添加一个notshow参数，值为true，用来提供判断 123456789---title: 《好好学习》—黄金思维圈date: 2018-06-12 11:45:43tags:- readcategories:- readnotshow: true--- front-matter就是每次hexo new “post_name”创建的文章里面的开头。创建的文章存放在hexo根目录下的：source_posts中 修改主题的index.swig主题可能各不一样，但原理都是一样的，我拿我使用的next主题来示范。路径：Hexo\themes\next\layout\index.swig 1234567891011121314151617181920212223&#123;% extends '_layout.swig' %&#125;&#123;% import '_macro/post.swig' as post_template %&#125;&#123;% import '_macro/sidebar.swig' as sidebar_template %&#125;&#123;% block title %&#125;&#123;&#123; config.title &#125;&#125;&#123;% if theme.index_with_subtitle and config.subtitle %&#125; - &#123;&#123;config.subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125;&#123;% block page_class %&#125; &#123;% if is_home() %&#125;page-home&#123;% endif -%&#125;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;section id="posts" class="posts-expand"&gt; &#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125; &lt;/section&gt; &#123;% include '_partials/pagination.swig' %&#125;&#123;% endblock %&#125;&#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125;&#123;% endblock %&#125; 修改这里： 123456789&#123;% block content %&#125; &lt;section id="posts" class="posts-expand"&gt; &#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125; &lt;/section&gt; &#123;% include '_partials/pagination.swig' %&#125;&#123;% endblock % 改成： 1234567891011&#123;% block content %&#125; &lt;section id="posts" class="posts-expand"&gt; &#123;% for post in page.posts %&#125; &#123;% if post.notshow != true %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/section&gt; &#123;% include '_partials/pagination.swig' %&#125;&#123;% endblock %&#125; 在for循环迭代文章中判断文章中的属性notshow，如果不为true就打印出文章。所以在需要隐藏的文章front-matter中添加notshow:true就可以了。 添加自定义菜单比如我想在菜单栏添加一个“阅读”选项，但又不想新建自己一个页面，于是可以直接使用分类的页面。创建新文章的时候直接指定categories: read配置 123456789---title: 《好好学习》—黄金思维圈date: 2018-06-12 11:45:43tags:- readcategories:- readnotshow: true--- 在git中使用hexo g命令，hexo会在根目录/public/categrises下自动生成分类中的阅读文件夹然后，配置主题配置文件themes/_config.yml中添加以下代码（#号后为注释内容） 123456menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th read: /categories/read #指定分类中阅读的路径]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好学习》—黄金思维圈]]></title>
    <url>%2F2018%2F06%2F12%2F%E3%80%8A%E5%A5%BD%E5%A5%BD%E5%AD%A6%E4%B9%A0%E3%80%8B%E2%80%94%E9%BB%84%E9%87%91%E6%80%9D%E7%BB%B4%E5%9C%88%2F</url>
    <content type="text"><![CDATA[在古典老师的《超级个体》上，我接触到了2W1H的概念，然后在《结构思考力》中，我认识到了2W1H在工作中的分析问题的本质的用法,，而在《好好学习》中的“黄金思维圈”中，我更加清楚知道了，生活中做的每一件事都可以用2W1H去进行思考，也就是说善于问“为什么”，这样能够更好地看透问题的本质。 黄金思维圈—我们看问题方式的三个层次第一层次是what层次：事情的表象，我们具体做的每一件事 第二层次是how层次：我们如何实现我们想要做的事 第三层次是why层次：我们为什么要这么做 本章其他内容应聘者对于过去工作进行介绍 what：很多应聘者思考问题停留在what层面，就是只看到问题的表象 why：技术层面的时候有很多成熟的方法，给予时间训练就能提高，而思维方式的问题，因为涉及很多底层的假设和思维模式，如果没有一定的基础是难以改变的。 how：不是仅仅局限在工作内容本身，还能清晰第认识这个工作是在什么背景格局下产生的，为什么要完成这个工作，完成这个工作的关键是什么，突破口是什么….. 销售的最高境界销售你的价值观，也就是销售你的why——你为什么存在。 关键语句伪需求看到的是需求的what层面，而真实的需求是要在what的表象之后挖掘到真正的why。 黄金思维圈最大的价值：透过问题的表象看到问题的本质 抓住why的本质，激发how的创意 引用《第五项修炼》：每个人不能只 囿于自己的岗位，觉得只做好分内之职就可以了，要对职位之间相互关联产生的结果富有一定责任。]]></content>
      <categories>
        <category>read</category>
      </categories>
      <tags>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask核心机制：current_app]]></title>
    <url>%2F2018%2F06%2F10%2Fflask%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9Acurrent-app%2F</url>
    <content type="text"><![CDATA[加深了对于Flask中current_app的理解，弥补了Miguel Grinberg的教程略过的知识点。 flask中经典错误 working outside application context错误：working outside application contex原因：在没有获取到应用上下文的情况下，进行了上下文操作。代码： 123456from flask import Flask, current_appapp = Flask(__name__)a = current_appd = current_app.config['DEBUG'] 运行： AppContext、RequestContext、Flask与Request之间的关系AppContext: 应用上下文，是对flask一切对象的封装 RequestContext: 请求上下文，是对request请求对象的封装 current_app: 类型是LocalProxy 像全局变量一样工作，但只能在处理请求期间且在处理它的线程中访问 返回的栈顶元素不是应用上下文，而是flask的应用实例对象 应用上下文的封装=flask核心对象+和外部协作对象（再flask封装对象上再添加push、pop等）（请求上下文同理）代码：F12进入current_app 1234567# context locals_request_ctx_stack = LocalStack()_app_ctx_stack = LocalStack()current_app = LocalProxy(_find_app)request = LocalProxy(partial(_lookup_req_object, 'request'))session = LocalProxy(partial(_lookup_req_object, 'session'))g = LocalProxy(partial(_lookup_app_object, 'g')) current_app与reques：current_app和reques都是设计模式中代理设计的代理对象，指向flask核心对象和reques的请求类 详解flask上下文与出入栈在pycharm的flask项目中可以通过：External Libraries-&gt;site-packages-&gt;flask-&gt;ctx.py可以看到源码的实现ctx.py中有AppContext、RequestContext两个函数，都实现了push()和pop()AppContext：123456789101112131415161718192021222324252627282930313233343536373839class AppContext(object): """The application context binds an application object implicitly to the current thread or greenlet, similar to how the :class:`RequestContext` binds request information. The application context is also implicitly created if a request context is created but the application is not on top of the individual application context. """ def __init__(self, app): self.app = app self.url_adapter = app.create_url_adapter(None) self.g = app.app_ctx_globals_class() # Like request context, app contexts can be pushed multiple times # but there a basic "refcount" is enough to track them. self._refcnt = 0 def push(self): """Binds the app context to the current context.""" self._refcnt += 1 if hasattr(sys, 'exc_clear'): sys.exc_clear() _app_ctx_stack.push(self) appcontext_pushed.send(self.app) def pop(self, exc=_sentinel): """Pops the app context.""" try: self._refcnt -= 1 if self._refcnt &lt;= 0: if exc is _sentinel: exc = sys.exc_info()[1] self.app.do_teardown_appcontext(exc) finally: rv = _app_ctx_stack.pop() assert rv is self, 'Popped wrong app context. (%r instead of %r)' \ % (rv, self) appcontext_popped.send(self.app) flask在RequestContext入栈前会检查另外一个AppContext的栈的情况，如果栈顶元素为空或者不是当前对象，就会把AppContext推入栈中，然后RequestContext才进栈。例如：过程就好比导游与游客。 导游-&gt;AppContext 游客-&gt;RequestContext 工作-&gt;push 消费-&gt;push 向导-&gt;current_app 游玩-&gt;request 旅程-&gt;LocalStack 每批游客都需要一位导游作为向导，人生地不熟如果没有向导就麻烦了，因此游客开始去游玩前需要有导游带团。在这旅程中，导游和游客虽然分别是工作和消费，但导游（对象:栈顶元素）的任务就是给游客提供向导（属性:app），不提供其他服务，而游客负责游玩。，当游客结束这旅程的同时导游的任务也完成（两个栈中的元素会被弹出）了。 手动AppContext进栈代码： 12345678from flask import Flask, current_appapp = Flask(__name__)ctx = app.app_context()ctx.push()a = current_appctx.pop() 运行：注意：但最终current_app返回的栈顶元素不是应用上下文，而是flask的应用实例对象!F12进入查看源码12345678910current_app = LocalProxy(_find_app)``` 查看**_find_app**函数``` def _find_app(): top = _app_ctx_stack.top if top is None: raise RuntimeError(_app_ctx_err_msg) return top.app 可以发现最后返回的是top对象中的app。reques和session同理，不过传多一个字符串进行查找。 flask自动入栈如果是在一个请求中直接使用current_app对象是不用手动把AppContext推入栈中的。如之前所说RequestContext入栈前会检查另外一个AppContext的栈的情况，这个操作会由flask帮你完成。 手动进栈存在的价值单元测试不在reques请求环境中执行，需要手动AppContext进栈。离线应用。例如待会介绍的异步邮箱例子。 flask上下文与with语句可以使用with 来实现自动入栈和出栈，比上面手动push、pop的更优雅，因为在AppContext中已实现两个特殊方法enter、exit，也被称为“魔法方法”，凡是实现了这两个特殊方法的对象都可以被with所使用。123456def __enter__(self): self.push() return selfdef __exit__(self, exc_type, exc_value, tb): self.pop(exc_value) python with的使用这里不详细讨论,在flask中注意的是： 实现了上下文协议的对象使用with with被称做上下文管理器 只要实现enter、exit就是实现上下文协议 上下文表达式（app.app_context()）必须返回一个上下文管理器（AppContext） exit最后三个参数记录发生异常时的信息，exit返回bool类型，返回true表示正常，false会抛出异常，没有返回值默认为false 代码： 123456from flask import Flask, current_appapp = Flask(__name__)with app.app_context(): a = current_app 运行：上图中全局变量a在with的作用域中的值为flask应用的实例对象main,当with关闭后就变成了LocalProxy unbound flask中实际应用发送密码重置电子邮件123456789101112131415161718from flask import render_templatefrom app import app# ...def send_password_reset_email(user): """ 令牌，生成密码重置电子邮件 """ token = user.get_reset_password_token() # 调用email.py中的send_email函数 send_email('[Microblog] Reset Your Password', sender=app.config['ADMINS'][0], recipients=[user.email], text_body=render_template('email/reset_password.txt', user=user, token=token), html_body=render_template('email/reset_password.html', user=user, token=token)) 异步电子邮件email.py: 123456789101112131415161718192021222324from threading import Threadfrom flask import current_appfrom flask_mail import Messagefrom app import maildef send_async_email(app, msg): with app.app_context(): mail.send(msg)def send_email(subject, sender, recipients, text_body, html_body, attachments=None, sync=False): msg = Message(subject, sender=sender, recipients=recipients) msg.body = text_body msg.html = html_body if attachments: # 附件 for attachment in attachments: msg.attach(*attachment) if sync: # 是否异步 mail.send(msg) else: Thread(target=send_async_email, args=(current_app._get_current_object(), msg)).start() send_async_email()mail.send()方法需要访问电子邮件服务器的配置值，而这必须通过访问应用属性的方式来实现。 使用with app.app_context()调用创建的应用上下文使得应用实例可以通过来自Flask的current_app变量来进行访问。 send_email()：在send_email()函数中，应用实例作为参数传递给后台线程，后台线程将发送电子邮件而不阻塞主应用程序。在作为后台线程运行的send_async_email()函数中直接使用current_app将不会奏效，因为current_app是一个与处理客户端请求的线程绑定的上下文感知变量。在另一个线程中，current_app没有赋值。直接将current_app作为参数传递给线程对象也不会有效，因为current_app实际上是一个代理对象，它被动态地映射到应用实例。因此，传递代理对象与直接在线程中使用current_app相同。我需要做的是访问存储在代理对象中的实际应用程序实例，并将其作为app参数传递。 current_app._get_current_object()表达式从代理对象中提取实际的应用实例，所以它就是我作为参数传递给线程的。]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之NexT主题 icon一直显示默认样式]]></title>
    <url>%2F2018%2F06%2F09%2Fnext%E4%B9%8Bicon%2F</url>
    <content type="text"><![CDATA[今天配置了一下午的next主题，也遇到了一些问题，主要还是官方教程和网上的教程贴都是按照以前的next版本的，印象深刻的就是icon。无论网上还是官方文档有关于icon的图标设置都差不多如下12345678 GitHub: https://github.com/yourname 邮箱: mailto:test@gamil.comsocial_icons: enable: true icons_only: false transition: false GitHub: github 邮箱: envelope 但在最新的next中这样配置会变成这样子：并且如果 icons_only: true 的话也会变成这样正确配置123456 GitHub: https://github.com/yourname || github 邮箱: mailto:test@gamil.com || envelopesocial_icons: enable: true icons_only: false transition: false 我还是在网上查找后才解决，这次附上了图。其实主题配置文件_config.yml已经有注释的了，但新手刚刚接触的话可能直接按照官方或者网上教程来，而忽视了注释。嗯。。。hexo的上传图片也是个不太舒服的操作。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python sort与sorted]]></title>
    <url>%2F2018%2F06%2F09%2FPython%20sort%E4%B8%8Esorted%2F</url>
    <content type="text"><![CDATA[了解sort与sorted的排序 语法sort语法：python2:iterable.sort(cmp[, key[, reverse]])python3:iterable.sort(, key=None, reverse=False)sorted 语法：python2:sorted(iterable[, cmp[, key[, reverse]]])python3:sorted(iterable, , key=None, reverse=False) 参数iterable – 可迭代对象。cmp(python3中已经取消) – 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。在对一些字符串排序时，可以用key=str.lower来忽略大小写的排序，或者是用key=len进行基于字符串长度的排序。reverse–排序规则. reverse = True 或者 reverse = False(默认)。（cmp和key可以使用lambda表达式） 区别sort是成员函数，sorted是built-in内建函数（被解释器所调用）sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作 注意：在Python3版本中，sort和sorted已经取消了cmp，也就是说安装原先的方法已经无法满足根据两个参数的比较来排序的需求，但可以使用cmp_to_key 例1： 12345678&gt;&gt;&gt; students = [('danny', 'male', 15), ('Tom', 'male', 12), ('Jerry','female', 10)]&gt;&gt;&gt; sorted(students,key=lambda s: s[2]) #按照年龄来排序[('Jerry', 'female', 10), ('Tom', 'male', 12), ('danny', 'male', 15)]&gt;&gt;&gt; students#使用sorted，原来的列表没有变化[('danny', 'male', 15), ('Tom', 'male', 12), ('Jerry', 'female', 10)]&gt;&gt;&gt; students.sort(key=lambda s: s[2])&gt;&gt;&gt; students#使用了元素的函数sort自身发生了改变[('Jerry', 'female', 10), ('Tom', 'male', 12), ('danny', 'male', 15)] 例2：字符串排序，排序规则：小写-大写-奇数-偶数 123&gt;&gt;&gt; s = 'asdf234GDSdsf23'&gt;&gt;&gt; print("".join(sorted(s, key=lambda x: (x.isdigit(),x.isdigit() and int(x) %2 == 0,x.isupper(),x))))addffssDGS33224 1.x.isdigit()检测字符串是否只由数字组成，排序把数字放在右边,字母放在左边.2.x.isdigit() and int(x) % 2 == 0的作用是保证奇数在右，偶数在左。3.x.isupper()的作用是在前面基础上,保证字母小写在右大写在左.4.最后的x表示在前面基础上,对所有类别数字或字母排序。例3：要求1.正数在前负数在后 2.整数从小到大 3.负数从大到小 12345678&gt;&gt;&gt; list_a=[7, -8, 5, 4, 0, -2, -5]&gt;&gt;&gt; sorted(list_a,key=lambda x:(x&lt;0,abs(x)))[0, 4, 5, 7, -2, -5, -8]&gt;&gt;&gt; list_a[7, -8, 5, 4, 0, -2, -5]&gt;&gt;&gt; list_a.sort(key=lambda x:(x&lt;0,abs(x)))&gt;&gt;&gt; list_a[0, 4, 5, 7, -2, -5, -8] 先按照正负排先后，再按照大小排先后。 例子4使用cmp：来源牛客网编程题目原地址 https://www.nowcoder.com/practice/a6a656249f404eb498d16b2f8eaa2c60?tpId=85&amp;&amp;tqId=29898&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking 题目内容如下 设有n个正整数，将他们连接成一排，组成一个最大的多位整数。如:n=3时，3个整数13,312,343,连成的最大整数为34331213。如:n=4时,4个整数7,13,4,246连接成的最大整数为7424613。输入描述:有多组测试样例，每组测试样例包含两行，第一行为一个整数N（N&lt;=100），第二行包含N个数(每个数不超过1000，空格分开)。输出描述:每组数据输出一个表示最大的整数。示例1输入 212 12347 13 4 246输出 123127424613 python2： 12345678def cmp(a, b): ab = int(a+b) ba = int(b+a) return 1 if ab &gt; ba else -1 num = input() l=raw_input().split(' ') l.sort(cmp, reverse=True) print int(''.join(l)) python3： 1234567891011from functools import cmp_to_key #导入使用cmp_to_keydef cmp(a, b): ab = int(a+b) ba = int(b+a) return 1 if ab &gt; ba else -1 num = input() l=input().split(' ') #python3中把python2的row_input(str)和iuput(int)结合到inptu(str)一起l.sort(key=cmp_to_key(cmp), reverse=True) print(int(''.join(l))) python3中sort和sorted取消了对cmp的支持，并且key接受一个函数，这个函数只接受一个元素，而当需要两个元素来进行比较时可以使用functools.cmp_to_key。 后记key 和 reverse 比一个等价的 cmp 函数处理速度要快。这是因为对于每个列表元素，cmp 都会被调用多次，而 key 和 reverse 只被调用一次可选参数key还可以在内置函数min()和max()中起作用。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
