<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python sort与sorted]]></title>
    <url>%2F2018%2F06%2F09%2FPython%20sort%E4%B8%8Esorted%2F</url>
    <content type="text"><![CDATA[语法sort语法：python2:iterable.sort(cmp[, key[, reverse]])python3:iterable.sort(, key=None, reverse=False)sorted 语法：python2:sorted(iterable[, cmp[, key[, reverse]]])python3:sorted(iterable, , key=None, reverse=False) 参数iterable – 可迭代对象。cmp(python3中已经取消) – 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。在对一些字符串排序时，可以用key=str.lower来忽略大小写的排序，或者是用key=len进行基于字符串长度的排序。reverse–排序规则. reverse = True 或者 reverse = False(默认)。（cmp和key可以使用lambda表达式） 区别sort是成员函数，sorted是built-in内建函数（被解释器所调用）sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作 注意：在Python3版本中，sort和sorted已经取消了cmp，也就是说安装原先的方法已经无法满足根据两个参数的比较来排序的需求，但可以使用cmp_to_key 例1： 12345678&gt;&gt;&gt; students = [('danny', 'male', 15), ('Tom', 'male', 12), ('Jerry','female', 10)]&gt;&gt;&gt; sorted(students,key=lambda s: s[2]) #按照年龄来排序[('Jerry', 'female', 10), ('Tom', 'male', 12), ('danny', 'male', 15)]&gt;&gt;&gt; students#使用sorted，原来的列表没有变化[('danny', 'male', 15), ('Tom', 'male', 12), ('Jerry', 'female', 10)]&gt;&gt;&gt; students.sort(key=lambda s: s[2])&gt;&gt;&gt; students#使用了元素的函数sort自身发生了改变[('Jerry', 'female', 10), ('Tom', 'male', 12), ('danny', 'male', 15)] 例2：字符串排序，排序规则：小写-大写-奇数-偶数 123&gt;&gt;&gt; s = 'asdf234GDSdsf23'&gt;&gt;&gt; print("".join(sorted(s, key=lambda x: (x.isdigit(),x.isdigit() and int(x) %2 == 0,x.isupper(),x))))addffssDGS33224 1.x.isdigit()检测字符串是否只由数字组成，排序把数字放在右边,字母放在左边.2.x.isdigit() and int(x) % 2 == 0的作用是保证奇数在右，偶数在左。3.x.isupper()的作用是在前面基础上,保证字母小写在右大写在左.4.最后的x表示在前面基础上,对所有类别数字或字母排序。例3：要求1.正数在前负数在后 2.整数从小到大 3.负数从大到小 12345678&gt;&gt;&gt; list_a=[7, -8, 5, 4, 0, -2, -5]&gt;&gt;&gt; sorted(list_a,key=lambda x:(x&lt;0,abs(x)))[0, 4, 5, 7, -2, -5, -8]&gt;&gt;&gt; list_a[7, -8, 5, 4, 0, -2, -5]&gt;&gt;&gt; list_a.sort(key=lambda x:(x&lt;0,abs(x)))&gt;&gt;&gt; list_a[0, 4, 5, 7, -2, -5, -8] 先按照正负排先后，再按照大小排先后。 例子4使用cmp：来源牛客网编程题目原地址 https://www.nowcoder.com/practice/a6a656249f404eb498d16b2f8eaa2c60?tpId=85&amp;&amp;tqId=29898&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking 题目内容如下 设有n个正整数，将他们连接成一排，组成一个最大的多位整数。如:n=3时，3个整数13,312,343,连成的最大整数为34331213。如:n=4时,4个整数7,13,4,246连接成的最大整数为7424613。输入描述:有多组测试样例，每组测试样例包含两行，第一行为一个整数N（N&lt;=100），第二行包含N个数(每个数不超过1000，空格分开)。输出描述:每组数据输出一个表示最大的整数。示例1输入 212 12347 13 4 246输出 123127424613 python2： 12345678def cmp(a, b): ab = int(a+b) ba = int(b+a) return 1 if ab &gt; ba else -1 num = input() l=raw_input().split(' ') l.sort(cmp, reverse=True) print int(''.join(l)) python3： 1234567891011from functools import cmp_to_key #导入使用cmp_to_keydef cmp(a, b): ab = int(a+b) ba = int(b+a) return 1 if ab &gt; ba else -1 num = input() l=input().split(' ') #python3中把python2的row_input(str)和iuput(int)结合到inptu(str)一起l.sort(key=cmp_to_key(cmp), reverse=True) print(int(''.join(l))) python3中sort和sorted取消了对cmp的支持，并且key接受一个函数，这个函数只接受一个元素，而当需要两个元素来进行比较时可以使用functools.cmp_to_key。 后记key 和 reverse 比一个等价的 cmp 函数处理速度要快。这是因为对于每个列表元素，cmp 都会被调用多次，而 key 和 reverse 只被调用一次可选参数key还可以在内置函数min()和max()中起作用。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
