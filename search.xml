<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【成长】程序员的成长学习笔记]]></title>
    <url>%2F2018%2F08%2F28%2F%E3%80%90%E6%88%90%E9%95%BF%E3%80%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%88%90%E9%95%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[来自“极客时间”陈皓老师专栏的笔记。 1 | 程序员如何用技术变现（上） 要去经历大多数人经历不到的，要把学习时间花在那些比较难的地方。 要写文章就要写没有人写过的，或是别人写过，但我能写得更好的。 更重要的是，技术和知识完全是可以变现的。 2 | 程序员如何用技术变现（下）如何让自己的技能变现 一、千里之行，积于跬步取得一个个小成功，例如成功帮助别人解决技术上的问题。 二、关注有价值的东西看清市场需求-缺少有能力解决技术难题的人。 看清技术趋势-需要将一些老技术的本质吃得很透。 学习过程中多问自己几个问题： 这个技术解决什么问题？为什么别的同类技术做不到？ 为什么是这样解决的？有没有更好的方式？ 技术发展趋势： 出现之时，越多大型商业公司支持。 三、找到能体现价值的地方在一家高速发展的公司中，技术人员的价值可以达到最大化。 四、动手能力很重要动手才能发现细节、了解细节，最终超越。 五、关注技术付费点帮助别人“挣钱”或“省钱”-慕课网实战课。 六、提升自己的能力和经历付费的前提是信任。信任需要用你的能力和经历来填补-讲师的背景。 七、找到有价值的信息源Google是寻得的关键，英语能力是获得的关键。 八、输出观点和价值观厚积薄发 九、朋友圈很重要物以类聚，人以群分。 优质的朋友圈特点： 这些人都比较有想法、有观点，经验也比较丰富 这些人涉猎的面比较广 这些人都有或多或少的成功 这些人都是喜欢折腾喜欢搞事的人 这些人都对现状有些不满，并想做一些改变 这些人都有一定的影响力]]></content>
      <categories>
        <category>growth</category>
      </categories>
      <tags>
        <tag>growth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【架构】笔记三 | 模式与框架]]></title>
    <url>%2F2018%2F08%2F15%2F%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E7%AC%94%E8%AE%B0%E4%B8%89-%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[工程师与他那工具箱不可不说的故事 核心知识 模式与框架关注于解决问题。 模式与框架都在于复用 设计模式“设计模式” 是描述可复用的已成功的解决方案的抽象概念。 每种设计模式，对应着解决特定的一类问题。 既然特定对应，每个问题的类型似可以一样，但细节不尽相同，也就需要在开发过程中对应用设计模式把控，俗称“火候”。 框架框架就像是给程序员定制的开发脚手架。 一个框架是一个可复用的设计组件，它统一定义了高层设计和接口，使得从框架构建应用程序变变得非常容易。因此，框架可以算是打开“快速开发”与“代码复用”这两扇门的钥匙。 框架是面向编程或配置的半成品，是“工程师”。 区别框架和模式的共同点在于，它们都提供了一种问题的重用解决方案。其中，框架是代码复用，模式是设计复用。 软件开发是一种知识与智力的活动，知识的积累很关键。框架采用了一种结构化的方式来对特定的编程领域进行了规范化，在框架中直接就会包含很多模式的应用、模式的设计概念、领域的优化实践等，都被固化在了框架之中。 框架是程序代码，而模式是关于这些程序代码的知识。 小结 模式是代码层面，解决单个问题的成功方法 框架是设计层面，解决一系列问题的成功方法 ”架构“是设计图纸，“框架”是工程师，而“设计模式”是工程师按照设计图纸打造实现目标过程中使用工具，而打造的东西不一样工具当然不止一样。 工程师拿着工具对着设计图纸打造目标。 工具在于解决打造过程中的问题 工程师在于解决“实现目标”这个问题]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Go】笔记三 | 库源码文件]]></title>
    <url>%2F2018%2F08%2F15%2F%E3%80%90Go%E3%80%91%E7%AC%94%E8%AE%B0%E4%B8%89-%E5%BA%93%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[库源码文件不能被直接运行，它仅用于存放程序实体。只要遵从 Go 语言规范，这些程序实体就可以被其他代码使用。 核心知识 代码包声明 代码包引用 模块级私有internal 程序实体是什么？在 Go 语言中，它是变量、常量、函数、结构体和接口的统称。 代码包声明的基本规则 第一条规则，同目录下的源码文件的代码包声明语句要一致。也就是说，它们要同属于一个代码包。这对于所有源码文件都是适用的。 第二条规则，源码文件声明的代码包的名称可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。 什么样的程序实体才可以被当前包外的代码引用？名称的首字母为大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。 对于程序实体，还可以使用怎样的访问权限规则？通过创建internal代码包让一些程序实体仅仅能被当前模块中的其他代码引用。 这被称为 Go 程序实体的第三种访问权限：模块级私有。 具体规则是，internal代码包中声明的公开程序实体仅能被该代码包的直接父包及其子包中的代码引用。 当然，引用前需要先导入这个interna包。 对于其他代码包，导入该interna包都是非法的，无法通过编译。 额外知识如果需要导入两个代码包，而这两个代码包的导入路径的最后一级是相同的，比如：dep/lib/flag和flag，那么会产生冲突吗？import后路径最后一级相同，不一定会冲突。 分为两种情况: 如果文件夹下文件声明的包名相同，则肯定冲突，会报错redeclared。 如果文件夹下文件声明的包名不同，也不会冲突。 如果会产生冲突，那么怎样解决这种冲突，有几种方式？ 给包设置别名,调用的时候来区分开不同的package,比如:import(b “bbbb”) 导入的点操作，import(. “bbbb”)。这样就可以直接调用bbbb下面的函数而不用再bbbb.funcname的方式调用。 如果只是想引入某包并没有在代码中实际调用则可以这么处理来避免冲突:import(_ “bbbb”) 像第一问一样采取不同的包名声明，毕竟包名不一定要和文件夹名一样 小结 同一个文件夹下，包的声明语句需要相同，代表同一个包。 包名不需要和其所在的文件夹名相同。 首字母大小写来代表可见性，大写public/小写private 使用internal代码包模块级私有]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Go】笔记二 | 命令源码文件与命令行参数]]></title>
    <url>%2F2018%2F08%2F15%2F%E3%80%90Go%E3%80%91%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%91%BD%E4%BB%A4%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[自定义命令行参数 核心知识 自定义命令参数 创建私有的命令参数容器 首知 环境变量 GOPATH 指向的是一个或多个工作区，而每个工作区中都会有以代码包为基本组织形式的源码文件。 源码文件又分为三种，即：命令源码文件、库源码文件和测试源码文件，它们都有着不同的用途和编写规则。 命令源码文件的用途是什么，怎样编写它？典型回答 命令源码文件是程序的运行入口，是每个可独立运行的程序必须拥有的。 我们可以通过构建或安装生成与其对应的可执行文件，后者一般会与该命令源码文件的直接父目录同名。 通过构建或安装命令源码文件生成的可执行文件就可以被视为“命令”，既然是命令，那么就应该具备接收参数的能力。 例如，要实现根据运行程序时给定的参数问候某人代码 1234567891011121314151617package mainimport ( "flag" // [1] "fmt")var name stringfunc init() &#123; flag.StringVar(&amp;name, "name", "everyone", "The greeting object.") // [2]&#125;func main() &#123; flag.Parse() // [3] fmt.Printf("Hello, %s!\n", name)&#125; 解析 [1]导入flag包，这是Go 语言标准库中专门用于接收和解析命令参数的包。 [2]设置命令参数接受 4 个参数。 第 1 个参数是用于存储该命令参数的值的地址，具体到这里就是在前面声明的变量name的地址了，由表达式&amp;name表示。 第 2 个参数是为了指定该命令参数的名称，这里是name. 第 3 个参数是为了指定在未追加该命令参数时的默认值，这里是everyone 第 4 个函数参数，即是该命令参数的简短说明了，这在打印命令说明时会用到 还有一个与flag.StringVar函数类似的函数，叫flag.String。 这两个函数的区别是，后者会直接返回一个已经分配好的用于存储命令参数值的地址。 1var name = flag.String("name", "everyone", "The greeting object.") 这里的name保持的就是地址 [3]用于真正解析命令参数，并把它们的值赋给相应的变量。 因此最好把flag.Parse()放在main函数的函数体的第一行。 查看该命令源码文件的参数说明，–help：像上面这一串123456789101112131415161718这是命令构建上述命令源码文件时**临时生成的可执行文件的完整路径**。如果我们先构建这个命令源码文件再运行生成的可执行文件，就会这样：![](https://img-blog.csdn.net/2018081501263412?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)自定义命令源码文件的参数使用说明================这有很多种方式，最简单的一种方式就是**对变量flag.Usag重新赋值**。flag.Usag重新赋值-------------flag.Usage的类型是func()，即一种无参数声明且无结果声明的函数类型。注意，对flag.Usage的赋值必须在调用flag.Parse函数之前代码 import ( “flag” // [1] “fmt” “os”) var name string func init() { flag.StringVar(&amp;name, “name”, “everyone”, “The greeting object.”) // [2]} func main() { flag.Usage = func() { fmt.Fprintf(os.Stderr, “Usage of %s:\n”, “question”) flag.PrintDefaults() } flag.Parse() // [3] fmt.Printf(“Hello, %s!\n”, name)} 12345678910运行![](https://img-blog.csdn.net/20180815013215610?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)flag.CommandLine重新赋值------------------现在再深入一层，我们在调用flag包中的一些函数（比如StringVar、Parse等等）的时候，实际上是在**调用flag.CommandLine变量的对应方法**。*flag.CommandLine*相当于默认情况下的命令参数容器。所以，通过对*flag.CommandLine*重新赋值，我们可以更深层次地定制当前命令源码文件的参数使用说明。现在我们把main函数体中的那条对flag.Usage变量的赋值语句注销掉，然后在init函数体的开始处添加如下代码： flag.CommandLine = flag.NewFlagSet(“”, flag.ExitOnError)flag.CommandLine.Usage = func() { fmt.Fprintf(os.Stderr, “Usage of %s:\n”, “question”) flag.PrintDefaults()}1运行 **go run demo.go --help**后，其输出会与上一次的输出的一致。不过后面这种定制的方法更加灵活。比如，当我们把为flag.CommandLine赋值的那条语句改为 flag.CommandLine = flag.NewFlagSet(“”, flag.PanicOnError)12345678910111213141516171819运行结果![](https://img-blog.csdn.net/20180815015001719?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)会产生另一种输出效果。这是由于我们在这里传给flag.NewFlagSet函数的第二个参数值是**flag.PanicOnError**。flag.PanicOnError和flag.ExitOnError都是预定义在flag包中的**常量**。 flag.ExitOnError的含义是，告诉命令参数容器，当命令后跟--help或者参数设置的不正确的时候，在打印命令参数使用说明后**以状态码2结束当前程序**。状态码2代表用户错误地使用了命令，而flag.PanicOnError与之的区别是在最后抛出“**运行时恐慌（panic）**”。 上述两种情况都会在我们调用flag.Parse函数时被触发。运行时恐慌”是 Go 程序错误处理方面的概念创建私有的命令参数容器-----------在函数外再添加一个变量声明： var cmdLine = flag.NewFlagSet(“question”, flag.ExitOnError)12完整代码 package main import ( “flag” // [1] “fmt” “os”) var name stringvar cmdLine = flag.NewFlagSet(“”, flag.ExitOnError) func init() { cmdLine.Usage = func() { fmt.Fprintf(os.Stderr, “Usage of %s:\n”, “question”) cmdLine.PrintDefaults() } cmdLine.StringVar(&amp;name, “name”, “everyone”, “The greeting object.”) // [2]} func main() { cmdLine.Parse(os.Args[1:]) // [3] fmt.Printf(“Hello, %s!\n”, name)}`其中的os.Args[1:]指的就是我们给定的那些命令参数。这样做就完全脱离了flag.CommandLine。 这样更加灵活定制命令参数容器，并且完全不会影响到那个全局变量flag.CommandLine。 额外知识默认情况下，我们可以让命令源码文件接受哪些类型的参数值？int(int|int64|uint|uint64),float(float|float64)string,bool,duration(时间),var(自定义) 我们可以把自定义的数据类型作为参数值的类型吗？如果可以，怎样做？关键就是使用flag.var()，关键点在于需要实现flag包的Value接口。 小结 源码文件分为三种:命令,库，测试。 编写命令源码文件的命令参数关键包: flag。 可以通过重新赋值创建新的命令参数容器]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Go】笔记一 | 工作区和GOPATH]]></title>
    <url>%2F2018%2F08%2F14%2F%E3%80%90Go%E3%80%91%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8CGOPATH%2F</url>
    <content type="text"><![CDATA[工作区和 GOPATH 的概念和含义是每个 Go 工程师都需了解的。首发地址： 核心知识 GOPATH的意义在与代码结构分层 Go语言源码的组织方式 以代码包为基本组织单位 代码包与目录一一对应 目录有子目录，代码包也有子包 代码包中可以任意个.go 扩展名的源码文件，需要被声明为属于同一个代码包。 代码包的名称一般会与这些源码文件所在的目录同名。如果不同名，那么在构建、安装的过程中会以代码包名称为准。 每个代码包都会有导入路径。 代码包的导入路径是其他代码在使用该包中的程序实体时需要引入的路径。 在实际使用程序实体之前，我们必须先导入其所在的代码包。具体的方式就是import该代码包的导入路径。 1import "github.com/labstack/echo" 在工作区中，一个代码包的导入路径实际上就是从 src 子目录，到该包的实际存储位置的相对路径。 了解源码安装后的结果 源码文件通常会被放在某个工作区的 src 子目录下 安装后如果产生了归档文件，就会放进该工作区的 pkg 子目录 如果产生了可执行文件，就可能会放进该工作区的 bin 子目录。 归档文件存放的具体位置和规则 源码文件会以代码包的形式组织起来，一个代码包其实就对应一个目录。 安装某个代码包而产生的归档文件是与这个代码包同名的。 放置它的相对目录就是该代码包的导入路径的直接父级。比如，一个已存在的代码包的导入路径是github.com/labstack/echo生成的归档文件的相对目录就是 github.com/labstack， 文件名为 echo.a 归档文件的相对目录与 pkg 目录之间还有一级目录，叫做平台相关目录。平台相关目录的名称是由 build（也称“构建”）的目标操作系统、下划线和目标计算架构的代号组成的。 理解构建和安装 Go 程序的过程 构建使用命令go build，安装使用命令go install 构建-&gt;库源码文件-&gt;临时目录意义在于检查和验证 构建-&gt;命令源码文件-&gt;源码文件所在目录 安装-&gt;构建-&gt;链接-&gt;搬运到指定目录（如果安装是库源码源文件，那么就在pkg目录的某个子目录中）（如果安装是命令源码文件，那么就在bin目录的某个子目录中，或GOBIN） go build 命令一些可选项的用途和用法运行go build命令的时候，默认不会编译目标代码包所依赖的那些代码包。 如果被依赖的代码包的归档文件不存在，或者源码文件有了变化，那它还是会被编译。 执行命令的时候加入标记-a,可强制编译。 此时，不但目标代码包总是会被编译，它依赖的代码包也总会被编译，即使依赖的是标准库中的代码包也是如此。 确定哪些代码包被编译 -x 查看执行了哪些操作 -n 查看而不执行操作 -v 查看编译的代码包的名称，也-a搭配更可口噢 设置GOPATH有什么意义？除了环境变量 GOPATH 的值可以是一个目录的路径，也可以包含多个目录路径，每个目录都代表 Go 语言的一个工作区（workspace）。意义在于代码结构的分层。 源码文件放在工作区的src目录 归档文件放在工作区的pkg目录 可执行文件放在工作区的bin目录 归档文件的相对目录与 pkg 目录之间还有一级目录，叫做平台相关目录。 知识补充 命令源码文件，即包含 main() 入口函数的源码文件。 归档文件，就是archive文件，也就是常见的.a文件，实际上就是将多个源码文件编译生成的目标文件（.o）打包归档成一份.a文件，这是程序编译后生成的静态库文件。 额外知识Go 语言在多个工作区中查找依赖包的时候是以怎样的顺序进行的？三个纬度延伸总结回答: 总执行顺序的角度引入的包 -&gt; 当前包的变量常量 -&gt; init()[多个同一包则按照顺序执行] -&gt; main函数 依赖包执行顺序被依赖的总是优先执行初始化，一个包只会被初始化一次。 a引入b，b引入c，则执行顺序c -&gt; b -&gt; a 单个包执行顺序的角度总的前提:按照包中源文件名的字典顺序来排序执行。当前包排序后的变量常量 -&gt; 排序后的init() 如果在多个工作区中都存在导入路径相同的代码包会产生冲突吗？不冲突，因为按顺序找到所需要的包就不往后找了。 小结 环境变量 GOPATH 指向的是一个或多个工作区，而每个工作区中都会有以代码包为基本组织形式的源码文件。 GOPATH的意义在与代码结构分层 ———————————————————————————————— 笔记来源：]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【进阶攻略】初惑:技术方向的选择]]></title>
    <url>%2F2018%2F08%2F07%2F%E3%80%90%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5%E3%80%91%E5%88%9D%E6%83%91-%E6%8A%80%E6%9C%AF%E6%96%B9%E5%90%91%E7%9A%84%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[选择语言选择技术方向，从某种意义上讲就是选择语言。 “语言不重要，必要的时候可以在各种语言之间切换”的前提是对一门语言掌握通透才能触类旁通。 掌握通透，不但需要掌握语言本身，还需要熟悉语言背后的整个生态圈。 掌握生态圈需要耗费大量的时间，而生态圈也一直在扩展。 选择展示蓬勃生命的语言，比如当下的python、Go。 选择回报选择技术方向，选择语言，本质都是一种投资。 焦虑在于技术更新快速，而之前付出时间获得的成果被淘汰。 越年轻的语言和方向，风险越高。 高风险未必带来高回报。 选择确定性的回报，要比抱着赌一把的心态更可取 看看当前的市场需求是什么，最需要什么，以及长期需要什么，再看看自己的基础能否翻越门槛。 技术总是短期被高估，但长期被低估。 技术的选择，都是赚取长期回报，短期的波动放在长期来看终将被抵。 . 选择行业搞清楚了语言、技术方向和回报的关系后，最后做出选择的立足点通常会落在行业上。一个问题就像一把锁，开锁的钥匙肯定不会在锁上。 选语言，就是选职业，而选职业首先选行业。 自己想从事哪个行业的软件开发？ 这个行业的现状如何？ 行业的平均增速如何？ 和其他行业相比如何？ 这个行业里最好的公司相比行业平均增速又如何？ 这些最好的公司都用些什么样的技术栈和语言？ 想进入这样的公司，就选择学这样的技术和语言。 关于选择选择的前提是为了获得安身立命的本领，获得竞争的相对优势。 一旦把兴趣变成了职业也就失去了兴趣，职业里面还有很多“不好玩”。 学习编程的一部分是学习语言的语法结构，更多的是学习如何像一个工程师一样解决问题。 有时选择困难，是因为缺乏足够的信息做出最优解。 无法获得决策所需的所有信息时，不要追求最优决策，而要追求满意决策。 停留在原地纠结，什么也不会改变。 ————————————————————————笔记来源：]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【架构】笔记二 | 架构设计的目的]]></title>
    <url>%2F2018%2F07%2F31%2F%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E7%AC%94%E8%AE%B0%E4%BA%8C-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%9B%AE%E7%9A%84%2F</url>
    <content type="text"><![CDATA[为了收益最大化 核心内容 架构设计的核心是分析复杂度 架构即是收益决策 首先要明白的是，架构就是一种设计，一种设计思想。 架构设计常见误区因为框架很重要，所以要做框架设计-》正确的废话 不做框架设计系统就跑不起来么？ 不然 做了框架设计就能提高开发效率么？ 不尽然 设计良好的架构能促进业务发展么？ 不好说 不是每个系统都要做框架设计吗-》知其然不知其所以然公司流程要求系统开发过程中必须有架构设计-》舍本逐末为了高性能、高可用、可扩展，所以要做框架设计-》画蛇添足 架构设计的真正目的架构也是为了应对软件系统复杂度而提出的一个解决方案，通过回顾架构产生的历史背景和原因，我们可以基本推导出答案：架构设计的主要目的是为了解决软件系统复杂度带来的问题。 明确了“架构设计是为了解决软件复杂度”原则后，很多架构上的困惑都可以很好回答。 “这么多需求，从哪里开始下手进行架构设计呢？” ——通过熟悉和理解需求，识别系统复杂性所在的地方，然后针对这些复杂点进行架构设计。 “架构设计要考虑高性能、高可用、高扩展……这么多高 XX，全部设计完成估计要 1 个月，但老大只给了 1 周时间” ——架构设计并不是要面面俱到，不需要每个架构都具备高性能、高可用、高扩展等特点，而是要识别出复杂点然后有针对性地解决问题。 “业界 A 公司的架构是 X，B 公司的方案是 Y，两个差别比较大，该参考哪一个呢？” ——理解每个架构方案背后所需要解决的复杂点，然后才能对比自己的业务复杂点，参考复杂点相似的方案。 分析复杂度分析复杂度分析复杂度 当我们对任何一个系统无论是进行架构设计还是更改的时候，首先应识别其复杂度到底体现在哪里 基于系统业务应用场景分析复杂度，分析复杂度是为了跟系统业务应用场景相贴合。 案例分析比如要搭建一个“学生管理系统”，分析复杂度 性能：学校学生人数不多，访问频率不高，存储用 MySQL 完全能够胜任，缓存都可以不用，Web 服务器用 Nginx 绰绰有余。 可扩展性：学生管理系统的功能比较稳定，可扩展的空间并不大，因此可扩展性也不复杂。 高可用：学生管理系统即使宕机 2 小时，对学生管理工作影响并不大，因此可以不做负载均衡，更不用考虑异地多活这类复杂的方案了。但是，如果学生的数据全部丢失，修复是非常麻烦的，只能靠人工逐条修复，这个很难接受，因此需要考虑存储高可靠，这里就有点复杂了。我们需要考虑多种异常情况：机器故障、机房故障，针对机器故障，我们需要设计MySQL 同机房主备方案；针对机房故障，我们需要设计 MySQL 跨机房同步方案。 安全性：学生管理系统存储的信息有一定的隐私性，例如学生的家庭情况，但并不是和金融相关的，也不包含强隐私（例如玉照、情感）的信息，因此安全性方面只要做3 个事情就基本满足要求了：Nginx 提供 ACL 控制、用户账号密码管理、数据库访问权限控制。 成本：由于系统很简单，基本上几台服务器就能够搞定，对于一所大学来说完全不是问题，可以无需太多关注。 对应架构如下: “复杂度”可以简单理解成“成本”,“复杂度带来的问题”就是“成本收益难度”，而“分析复杂度”就是“成本收益分析”，也就是说架构设计的目的是为了“收益最大化” 架构设计过程架构即决策，收益决策明确需求-&gt;分析复杂度-&gt;做出决策。 知识复盘架构设计核心是什么？分析复杂度（成本收益分析） 架构设计的目的是什么？解决复杂度的问题（成本收益难度） 小结 架构设计是为了解决软件复杂度 优秀的架构设计能更好地收益最大化]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【网络协议】笔记六 | 交换机与VLAN]]></title>
    <url>%2F2018%2F07%2F30%2F%E3%80%90%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%91%E7%AC%94%E8%AE%B0%E5%85%AD-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%8EVLAN%2F</url>
    <content type="text"><![CDATA[暂时还没有完全理解，笔记逻辑存在一些BUG 核心知识点 STP协议解决交换机环路问题 理解STR协议 使用VLAN解决广播域冲突 宿舍使用一台交换机就完全没有问题了，但要是写字楼办公室的可以就需要多台交换机了。多台交换机连接起来，就形成稍微复杂的拓扑结构。 拓扑结构的形成 两台交换机 机器1只知道机器4的IP地址，还需要机器4的MAC地址才能把包送到机器4 机器1发起广播，没机器2的事 交换机A收到，转发给出了来源处的其他网口 机器3收到，也没机器3的事 交换机B连着局域网LAN2，所以交换机B也收到，也继续广播 机器4和机器5收到，机器4响应MAC地址 ARP请求成功 机器的链路层能够学习，交换机也能够学习 机器A当经过一次交换机A，那么交换机A以后都知道机器A是在左边局域网LAN1 机器多了，多台交换机就有可能连接着相同的两个LAN，就回形成环路 解决常见的环路问题 机器1需要访问机器2 交换机A此时还没有学习，并不知道A是在LAN1还是LAN2于是，广播到LAN2 LAN2存在着这个广播包，于是交换机B从右边接受到LAN2过来的广播包，广播到LAN1 交换机A此时还是不知道机器2在哪，于是再次广播到LAN2 不断重复3、4步骤 一开始交换机A和B都接受到左边LAN1中机器1的广播包，学习到机器1是在左边的LAN1中。 但当交换机AB把该广播包广播到右边LAN2时，A接受到来自B的广播包，B也接受到来自A的广播包，不断循环。 其他机器也继续发着广播包，通信链路越来越堵，最后走不动。 于是就产生了死循环的环路问题。 于是应用了STP协议 理解STP协议在数据结构中，有一个方法叫作最小生成树。有环的我们常称为图。将图中的环破了，就生成了树。在计算机网络中，生成树的算法叫作STP，全称Spanning Tree Protocol。 应用了STP协议的办公室交换机结构图 概念： Root Bridge-根交换机 Designate Bridges-子交换机 Bridge Protocol Data Units（BPDU）-网桥协议数据单位元 Priority Vector – 优先级向量 BPDU介绍 BPDU是交换机之间发送的用于构建无环路拓扑的消息称为网桥协议数据单元 BPDU是二层报文 BPDU中包括用于计算生成树的参数信息 Root Bridge ID （BID）—本交换机认为的根交换机ID Root Path Cost —本交换机认为的根交换机路径开销 Bridge ID —本交换机的ID Port ID—发送该BPDU的端口ID 也就是说BPDU代表两交换机连接的连接与开销 STR协议过程 哪个数字最小就是根交换机其他交换机哪条通往根交换机最短的路就是交换机转发广播包的路径最终转发路径如下 原本1-5-6是一个环，确定好最短通信路径，这个环通信就不成环了 5要是需要转发到1就，5-&gt;6-&gt;1 1要是需要转发到5就，1-&gt;6&gt;5 解决广播问题和安全问题机器多了，交换机多了，就需要划分广播域来更方便管理了两种划分方法物理隔离：配置单的独交换机，单独的子网，通过路由器（另讲）向其他广播域沟通虚拟隔离：VLAN，虚拟局域网。 如果交换机是支持VLAN的，可以设置交换机每个端口所属的VLAN，交换机会把广播包的二层头取下来，识别VLAN ID，广播包的转发只在相同的端口 VLAN ID中进行。 端口会根据所属VLAN ID在广播包二层头中加一个TAG再转发出去。 Tag里面有一个端口 VLAN ID，一共 12 位，可以划分4096个VLAN。用以确定那个相同VLAN ID端口接受。 具体可以参考以下链接内容：https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/419962?fromtitle=VLAN&amp;fromid=320429&amp;fr=aladdinhttp://network.51cto.com/art/201409/450885.htm 交换机之间通过叫做Trunk口来进行连接，用来转发属于任何VLAN的口。这里介绍的是一般复杂的的场景，还有云计算其他的另说。 知识复盘如何解决交换机环路问题？应用STP协议 如何划分广播域？物理隔离或者虚拟隔离VLAN，一般使用虚拟隔离 额外知识STP协议有什么缺点？ 拓扑收敛慢，当网络拓扑发生改变的时候，生成树协议需要50-52秒的时间才能完成拓扑收敛，数越大需要的时间越长，这期间就是网络中断。 不能提供负载均衡的功能。当网络中出现环路的时候，生成树协议简单的将环路进行Block，这样该链路就不能进行数据包的转发，浪费网络资源。 小结 当交换机的数目越来越多的时候，会遭遇环路问题，让网络包迷路造成广播风暴，这就需要使用 STP 协议，将有环路的图变成没有环路的树，从而解决环路问题。 交换机数目多会面临隔离问题，可以通过 VLAN 形成虚拟局域网，从而解决广播问题和安全问题。]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【架构】笔记一 | 初识框架与架构]]></title>
    <url>%2F2018%2F07%2F29%2F%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%88%9D%E8%AF%86%E6%A1%86%E6%9E%B6%E4%B8%8E%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[有些难啃 核心内容 组件是达到可复用要求的模块 架构是设计图纸，框架是工程师 系统与子系统“系统”的维基百科定义：系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体。它的意思是“总体”“整体”或“联盟”。”子系统“的维基百科定义：子系统也是由一群有关联的个体所组成的系统，多半会是更大系统中的一部分。 子系统的定义和系统定义是一样的，只是观察的角度有差异，一个系统可能是另外一个更大系统的子系统。例如 微信本身是一个系统，包含聊天、登录、支付、朋友圈等子系统 朋友圈这个系统又包括动态、评论、点赞等子系统 无论是系统还是子系统相对于自身系统而言，整个系统都是由个体也就是模块或组件构成的。 模块与组件 都是基于功能划分的单位 模块是从业务维度上职责的划分 组件是技术维度上的复用 从设计上来看，组件强调复用，模块强调职责(内聚、分离)，或者说组件是达到可复用要求的模块。 模块和组件都是系统的组成部分，只是从不同的角度拆分系统。 框架与架构 框架关注的是“规范”，是面向编程或配置的半成品 架构关注的是“结构”，是软件系统的金字塔结构 所谓结构，是指任何一件事情都可以看做一个系统。而任何一个系统，都有多个元素（个体）组成，这些系统组成的元素之间的关系形成结构 而规范就是要求按照这个结构进行操作的一个标准 架构是设计图纸，目的是“做什么”；框架是工程师，目的是“做出来”。 选择不同的框架就是选择不同的工程师。 哪怕是基于同一张设计图纸不同的工程师（不同的框架）做出来的效果各不一样（性能的差异）。 比如说Spring MVC框架这个工程师，他拿着MVC架构这张设计图开发出来web应用了。 这个web应用是MVC架构设计的，是基于Spring MVC框架开发的（这个web工程是按照MVC设计图纸开发的，是Spring MVC工程师做的） Spring MVC框架基于MVC架构设计开发了这个web应用（Spring MVC工程师按照MVC这设计图纸做出了这个web工程） 当我们想造一房子时，我们可以自己学习成为工程师（造轮子）来建造，但也许更好的选择是聘请专业的工程师（现成框架），我们提供材料（编写模块或组件）让其快速实现目标。 知识复盘当我们在谈架构的时候，其实是在谈什么？设计思想 当我们在谈框架的时候，其实是在谈什么？设计思想的具体化（用Spring、JSF、GWT哪个实现） 如何正确介绍一个系统的架构与框架？这个XXX系统是基于XXX 架构设计，基于XXX 框架开发的 小结 系统是基于架构设计，基于框架开发，由模块或组件构造。 凡是可以体现出设计思想的都可以看做是架构，凡是可以根据设计开发出产品的都可以看做框架。 最后，把“框架”比如成“工程师”，也许一下子理解不过来。其实框架就像是给程序员定制的开发脚手架，是一种半成品，是一种工具。就好比对于雇主我来说，要造房子，那么对于“造房子”这目标达成来说，工程师就是这达成过程中借助的一样工具。我给他设计图纸，他看得懂设计图纸，那么他就可以造得出来]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【网络协议】笔记五 | 从物理层到MAC层：如何在宿舍里自己组网玩联机游戏？]]></title>
    <url>%2F2018%2F07%2F28%2F%E3%80%90%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%91%E7%AC%94%E8%AE%B0%E4%BA%94-%E4%BB%8E%E7%89%A9%E7%90%86%E5%B1%82%E5%88%B0MAC%E5%B1%82%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%BF%E8%88%8D%E9%87%8C%E8%87%AA%E5%B7%B1%E7%BB%84%E7%BD%91%E7%8E%A9%E8%81%94%E6%9C%BA%E6%B8%B8%E6%88%8F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[网线+交换机 知识点 物理层与链路层 链路层与MAC层 HUB与交换机 第一层（物理层）两台电脑插网线互通，通信的前提两台电脑配好IP地址、子网掩码和默认网关。这样两台机器构成了局域网（LAN） 但有第三台机器协议连接的时候就需要HUB（现在基本被淘汰，使用交换机，另说）。 这种设备有多个口，可以将宿舍里的多台电脑连接起来。但是，和交换机不同，集线器没有大脑，它完全在物理层工作。它会将自己收到的每一个字节，都复制到其他端口上去。这是第一层物理层联通的方案。 第二层（数据链路层） 数据链路层分为上层LLC（逻辑链路控制），和下层的MAC（介质访问控制） MAC主要负责控制与连接物理层的物理介质。在发送数据的时候 MAC协议可以事先判断是否可以发送数据，如果可以发送将给数据加上一些控制信息，最终将数据以及控制信息以规定的格式发送到物理层 在接收数据的时候，MAC协议首先判断输入的信息并是否发生传输错误，如果没有错误，则去掉控制信息发送至LLC（逻辑链路控制）层 HUB采取的是广播的模式，广播数据包，但要解决几个问题： 这个包是发给谁的？谁应该接收？ 大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？ 如果发送的时候出现了错误，怎么办？ 这个包是发给谁的？谁应该接收？ 这里用到一个物理地址，叫做链路层地址但是因为第二层主要解决媒体接入控制的问题，所以它常被称为MAC地址 靠数据包中目标MAC地址，然后就是双子楼的模式（笔记二） 如果不知道MAC地址，就需要使用ARP协议在广播中“吼”，因为是在局域网中，所以能得到目标IP的回复 为了避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存 IP 随时会改变，所以 ARP 的 MAC 地址缓存过一段时间就会过期广播包中，具体的询问和回答的报文如下：大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？ MAC的全称是Medium Access Control，即媒体访问控制，制定多路访问规则来控制访问，防止发生混乱。这里可不关MAC地址的事噢 如果发送的时候出现了错误，怎么办？使用CRC，也就是循环冗余检测。通过 XOR 异或的算法，来计算整个包是否在发送的过程中出现了错误 局域网在局域网中，用HUB连接起来，一旦机器数目多了产生冲突的概率就提高了，如果这个区域里有冲突，所有电脑都受影响。而且把不需要的包转发过去纯属浪费。 于是就是需要使用交换机，交换机胡交换机会学习来知道每个口电脑的MAC地址：一开始把包转发给除了来的那个口之外的其他所有的的口，而接受到包的口如果不是目标就会把包的来源口记住，只要以后有包的目标地址是这个来口，直接发送这个口就行了。 然后这样重复一段时间，就有了整个网络的结构，这时基本不用广播，全部可以准确转发了 每个机器IP地址改变时，所在的口业会改变，因而交换机上的学习结果，称为转发表，是有一个过期时间。 知识复盘第一层物理层是干什么的？机器之间达成连接 第二层链路层是干什么的？管理包的接收 在局域网中知道目标IP地址如何寻找目标MAC？ARP请求 额外知识交换机和HUB有什么区别？ 交换机可以分割冲突域而 HUB不可以分割冲突域 ，这是他们最本质的区别hub连N台电脑，他们共享在一个区域里，如果这个区域里有冲突，所有电脑都受影响。交换机连n台电脑，每个交换机端口是一个独立的区域，即使有冲突，冲突也局限在相对应的交换机端口，不影响其他电脑 HUB是广播数据包，交换机是隔离数据包 链接：https://zhidao.baidu.com/question/175872130001476004.html 路由器与交换机有什么区别？ 工作层次不同：交换机比路由器更简单，路由器比交换器能获取更多信息 数据转发所依据的对象不同 传统的交换机只能分割冲突域，不能分割广播域;而路由器可以分割广播域 路由器提供了防火墙的服务 链接：http://network.51cto.com/art/201505/477755.htm 如果一个局域网里面有多个交换机，ARP 广播的模式会出现什么问题呢？ARP广播时，交换机会将一个端口收到的包转发到其它所有的端口上。 比如数据包经过交换机A到达交换机B，交换机B又将包复制为多份广播出去。 如果整个局域网存在一个环路，使得数据包又重新回到了最开始的交换机A，这个包又会被A再次复制多份广播出去。 如此循环，数据包会不停得转发，而且越来越多，最终占满带宽，或者使解析协议的硬件过载，行成广播风暴。 小结 物理层是连接，链路层是管理 MAC层是链路层的子层 MAC层是用来解决多路访问的堵车问题 ARP是通过“吼”的方式来寻找目标MAC地址 交换机是有MAC地址学习能力的，学完了它就知道谁在哪，不用广播]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【网络协议】笔记四 | DHCP与PXE：IP是怎么来的，又是怎么没的？]]></title>
    <url>%2F2018%2F07%2F27%2F%E3%80%90%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%91%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%9ADHCP%E4%B8%8EPXE%EF%BC%9AIP%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84%EF%BC%8C%E5%8F%88%E6%98%AF%E6%80%8E%E4%B9%88%E6%B2%A1%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[租来的 知识点 配置IP地址 房产中介DHCP 装修队PXE 如果需要和其他机器通讯，我们就需要一个通讯地址，我们需要给网卡配置这么一个地址。 如何配置 IP 地址？使用 net-tools： 12$ sudo ifconfig eth1 10.0.0.1/24 $ sudo ifconfig eth1 up 使用 iproute2： 12$ sudo ip addr add 10.0.0.1/24 dev eth1 $ sudo ip link set up eth1 之前说过，有了目标ip地址，还需要目标MAC地址，而最终的目标MAC地址需要经过一个个网关才可以寻得，而当前需要寻得的是当前局域网中的网关的MAC地址。Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。Linux会判断这个目标ip地址和自己的其中一个网卡是否同一个网段，才会发送ARP请求，获取网关的MAC地址，然后将包发出去。如果没有配置网关，包就发包出去。所以配置ip地址之前需要知道系统中网卡的网段，或者向管理员申请分配一段正确的ip地址。正配置的时候，一定不是直接用命令配置的，而是放在一个配置文件里面。不同系统的配置文件格式不同，但是无非就是 CIDR、子网掩码、广播地址和网关地址。 动态主机配置协议（DHCP）除了手动配置，还有一种是自动分配配置。自动配置的协议，也就是称动态主机配置协议（Dynamic Host Configuration Protocol），简称DHCP。网络管理员只需要备注一段共享ip地址，每一台新接入的机器都通过DHCP吸引，来这个共享的IP地址里申请，然后自动配置好就可以了，下线自动归还。如果是数据中心里面的服务器，IP 一旦配置好，基本不会变，这就相当于买房自己装修。DHCP 的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了。通信都是广播包的形式： 租客叫一声：我是XXX（MAC地址）要租房（IP地址） 许多房产中介立马带着资料（提供的IP地址）赶过来回应 租客选择一位回复最快最热情的房产中介，并告诉其他房产中介自己已经选择了那位房产中介，多谢其他房产中介并让他们拿回各自的资料给下一位租客 房产中介拿签订合同过来给租客确认进住 租客在租期过去一本的时候，需要告诉房产中介自己是否续期，然后房产中介回复更新确认租房信息，租客根据回复安排之后的一切。 网络管理员不仅能自动分配 IP 地址，还能帮你自动安装操作系.系统 预启动执行环境（PXE）例如数据中心要给几百台机器自动安装操作系统就需要PXE了。 PXE是什么？PXE(preboot execute environment，预启动执行环境)是由Intel公司开发的最新技术，工作于Client/Server的网络模式，支持工作站通过网络从远端服务器下载映像，并由此支持通过网络启动操作系统，在启动过程中，终端要求服务器分配IP地址，再用TFTP（trivial file transfer protocol）或MTFTP(multicast trivial file transfer protocol)协议下载一个启动软件包到本机内存中执行，由这个启动软件包完成终端（客户端）基本软件设置，从而引导预先安装在服务器中的终端操作系统。PXE可以引导多种操作系统，如：Windows95/98/2000/windows2003/windows2008/winXP/win7/win8,linux系列系统等。 PXE表现形式：PXE最直接的表现是，在网络环境下工作站可以省去硬盘，但又不是通常所说的无盘站的概念，因为使用该技术的PC在网络方式下的运行速度要比有盘PC快3倍以上。当然使用PXE的PC也不是传统意义上的TERMINAL终端，因为使用了PXE的PC并不消耗服务器的CPU，RAM等资源，故服务器的硬件要求极低。 PXE启动原理PXE 协议分为客户端和服务器端，由于还没有操作系统，只能先把客户端放在 BIOS 里面。当计算机引导时，BIOS把 PXE Client 调入内存中执行，然后由 PXE Client 将放置在远端的文件通过网络下载到本地运行解析 PXE 的工作过程 这里有些像装修队：新房啥也没有装修，然后找装修公司（DHCP Server）安排一只装修队（TFTP Server）学习，想弄啥就跟装修队说。 知识复盘在跨网段调用中，是如何获取目标IP的mac地址的？从源IP网关获取所在网关mac, 然后又替换为目标IP所在网段网关的mac, 最后是目标IP的mac地址 手动配置麻烦，怎么办？DHCP！Dynamic Host Configuration Protocol！DHCP, 让你自动配置IP，如同租客与房产中介商谈、签约、续租，广播还不能“抢单”。 如果新来的，房子是空的(没有操作系统)，怎么办？PXE， Pre-boot Execution Environment.“装修队”PXE，帮你安装操作系统。 小结 DHCP 协议主要是用来给客户租用 IP 地址，和房产中介很像，要商谈、签约、续租，广播还不能“抢单” DHCP 协议能给客户推荐“装修队”PXE，能够安装操作系统]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【网络协议】笔记三 | ifconfig：最熟悉又陌生的命令行]]></title>
    <url>%2F2018%2F07%2F26%2F%E3%80%90%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%91%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9Aifconfig%EF%BC%9A%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E9%99%8C%E7%94%9F%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[恩，熟悉的陌生人 知识点 查看IP地址 IP地址五大类 CIDR 私有与公有地址 怎么查看IP地址？通常Windows是ipconfig，linux是ifconfig，而linux还可以使用ip addr查看 例如运行ip addr 12345678910111213root@test:~# ip addr1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff inet 10.100.122.2/24 brd 10.100.122.255 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::f816:3eff:fec7:7975/64 scope link valid_lft forever preferred_lft forever IP 地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码。既然是门牌号码，就不能一样起冲突，好比大家都是六单元1001号，那快递就找不到地方了。如上输出的结果，10.100.122.2 就是一个 IP 地址。这个地址被点分隔为四个部分，每个部分 8 个 bit，所以 IP 地址总共是 32 位。但其实根本不够用，于是就有了IPv6地址，也就是上面输出结果里面 inet6 fe80::f816:3eff:fec7:7975/64，这个有 128 ，而位前面说32位的是IPv4。本来IPv4地址就不够，还被分成5大类 IP地址5大类 网络号 ：用于识别主机所在的网络； 主机号 ：用于识别该网络中的主机。 A类，保留给政府机构 B类，分配给中等规模的公司 C类，分配给任何需要的人 D类，用于组播 E类，用于实验，各类可容纳的地址数目不同 在网络地址中，至少在当时设计的时候，对于 A、B、 C 类主要分两部分，前面一部分是网络号，后面一部分是主机号。这很好理解，大家都是六单元 1001 号，我是小区 A 的六单元 1001 号，而你是小区 B 的六单元 1001 号。 下面这个表格，详细地展示了 A、B、C 三类地址所能包含的主机的数量 这里拿C类地址说明，C类地址主机号是8位，也就2的8次方应该是256个主机，但能连却只有254，这是因为还有一个是广播地址，一个是路由地址，所以少了2个！比如192.168.0.255用于192.168.0.段的广播了，而192.168.0.0分配成你的路由器地址了，所以机子少了2个。但C类的主机太少，而D类的太多，于是就有了现在折中的CIDR 无类型域间选路（CIDR）特点 CIDR主要是为了更有效分配和管理IPv4地址，CIDR使IP地址又回到无分类的两级编码。记法：IP地址：：={&lt;&lt;网络前缀&gt;，&lt;&lt;主机号&gt;}。CIDR还使用“斜线记法”即在IP地址后面加上“/”然后写网络前缀所占的位数。 CIDR把网络前缀都相同的连续IP地址组成一个“CIDR地址块”，即强化路由聚合（构成超网）。 伴随着 CIDR 存在的，一个是广播地址，10.100.122.255。如果发送这个地址，所有10.100.122 网络里面的机器都可以收到。另一个是子网掩码 255.255.255.0。 Ａ类的默认子网掩码 255.0.0.0 Ｂ类的默认子网掩码 255.255.0.0 Ｃ类的默认子网掩码 255.255.255.0 IP地址和子网掩码都转换为二进制做逻辑与运算的结果为本网段的网络号，是区分不同网段的方法。 例：192.168.1.1（11000000.10101000.00000001.00000001） 255.255.255.0（11111111.11111111.11111111.00000000）两个做与运算： 11000000.10101000.00000001.00000000（192.168.1.0）即192.168.1.0为本网段的网络号 更多CIDR的详解可以阅读以下文章：http://www.cnblogs.com/wxgblogs/p/5628092.htmlhttp://blog.sina.com.cn/s/blog_5edae1a101018hgo.html 公有 IP 地址和私有 IP 地址IP地址由IANA（Internet地址分配机构）管理和分配，任何一个IP地址要能够在Internet上使用就必须由IANA分配，IANA 分配的能够在Internet上正常使用的IP地址称之为公共IP地址；IANA保留了一部份IP地址没有分配给任何机构和个人，这部份IP地址不能在 Internet上使用，此类IP地址就称之为私有IP地址。为什么私有IP地址不能在Internet上使用呢？因为Internet上没有私有IP地 址的路由。我们继续看上面的表格。表格最右列是私有 IP 地址段。平时我们看到的数据中心里，办公室、家里或学校的 IP 地址，一般都是私有 IP 地址段。因为这些地址允许组织内部的 IT 人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有 IP 地址段和我学校的可以是一样的。这就像每个小区有自己的楼编号和门牌号，你们小区可以叫 6 栋，我们小区也叫 6 栋，没有任何问题。但是一旦出了小区，就需要使用公有 IP 地址。就像人民路 888 号，是国家统一分配的，不能两个小区都叫人民路 888 号。 如何得出网络号、掩码、广播地址？例如CIDR 10.100.122.2/24，后面 24 的意思是，32 位中，前 24 位是网络号，后 8 位是主机号；32位子网掩码前24位是1，后8位是0。 由子网掩码和IP地址的进行二进制“与”运算，算出网络地址； 网络地址二进制后连续的0栋变成1就是广播地址； 网络地址+1就是第一个主机二进制地址，广播低价-1即为最后一个主机地址 可用主机的数量=2^二进制位数的主机-2 减2是因为主机不包括网络地址和广播地址。 参考：https://blog.csdn.net/gatieme/article/details/50989257http://uule.iteye.com/blog/2102484https://zhidao.baidu.com/question/1116507203928197699.html 继续了解ip addr在 IP 地址的后面有个 scope，对于 eth0 这张网卡来讲，是 global，说明这张网卡是可以对外的，可以接收来自各个地方的包。对于 lo 来讲，是 host，说明这张网卡仅仅可以供本机相互通信。lo 全称是loopback，又称环回接口，往往会被分配到 127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。 MAC地址在 IP 地址的上一行是 link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff，这个被称为MAC地址，是一个网卡的物理地址，用十六进制，6 个 byte 表示。 网络设备的状态标识解析完了 MAC 地址，我们再来看 BROADCAST,MULTICAST,UP,LOWER_UP&gt; 是干什么的？这个叫作net_device flags，网络设备的状态标识。 UP 表示网卡处于启动的状态 BROADCAST 表示这个网卡有广播地址，可以发送广播包 MULTICAST 表示网卡可以发送多播包 LOWER_UP 表示 L1 是启动的，也即网线插着呢 MTU1500 是指什么意思呢？是哪一层的概念呢？ 最大传输单元 MTU 为 1500，这是以太网的默认值。 上一节，我们讲过网络包是层层封装的。MTU 是二层 MAC 层的概念。MAC 层有 MAC 的头，以太网规定连 MAC 头带正文合起来，不允许超过 1500 个字节。正文里面有 IP 的头、TCP 的头、HTTP 的头。如果放不下，就需要分片来传输。 qdisc pfifo_fast 是什么意思呢？qdisc 全称是queueing discipline，中文叫排队规则。内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的 qdisc（排队规则）把数据包加入队列。 最简单的 qdisc 是 pfifo，它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。pfifo_fast 稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用先进先出规则。 三个波段（band）的优先级也不相同。band 0 的优先级最高，band 2 的最低。如果 band 0 里面有数据包，系统就不会处理 band 1 里面的数据包，band 1 和 band 2 之间也是一样。 数据包是按照服务类型（Type of Service，TOS）被分配多三个波段（band）里面的。TOS 是 IP 头里面的一个字段，代表了当前的包是高优先级的，还是低优先级的。 知识复盘IP地址五大类作用于何处？A类保留给政府机构，B类分配给中等规模的公司，C类分配给任何需要的人，D类用于组播，E类用于实验，各类可容纳的地址数目不同。 IP设计时犯的错误？低估了未来网络的发展，32位地址不够用。于是有了现在IPv6（128位） 分类错误。分成了5类。C类太少，B类太多。C类254个，网络都不够；D类6万多，给企业都太多。 那后来者如何弥补IP设计者犯的错误呢？ CIDR，无类型域间选路。 打破原来几类地址设计的做法，将32位IP地址一分二，前者网络号，后者主机号。 如何分呢？ 例子：10.100.122.2/24 前24位是网络号，那么后8位就是主机号。 那如何用？ 如发送行信息给 10.100.122.255 所有以 10.100.122… 开头的机器都能收到。 于是有了两个概念： 广播地址：10.100.122.255 子网掩码：255.255.255.0。 每一个城市都有人民广场，IP设计是如何解决的？公有IP地址和私有IP地址。 搭建世界人民都可以访问的网站，需要共有IP地址 搭建只有学校同学使用饿的网站，只要私有IP地址例子1: Wi-Fi 192.168.0.x 是最常用的私有 IP 地址 192.168.0 是网络号 192.168.0.1，往往就是你这个私有网络的出口地址 192.168.0.255 就是广播地址。一旦发送这个地址，整个 192.168.0 网络里面的所有机器都能收到。 如何理解MAC地址？IP是地址，有定位功能；Mac就是身份证，唯一识别。 IP地址scope是什么意思？对于 eth0 这张网卡来讲，是 global，说明这张网卡是可以对外的，可以接收来自各个地方的包。对于 lo 来讲，是 host，说明这张网卡仅仅可以供本机相互通信。 lo是什么意思？lo 全称是loopback，又称环回接口，往往会被分配到 127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。 BROADCAST,MULTICAST,UP,LOWER_UP &gt; 是干什么的？ net_device flags，网络设备的状态标识 UP 表示网卡处于启动的状态 BROADCAST 表示这个网卡有广播地址，可以发送广播包 MULTICAST 表示网卡可以发送多播包 LOWER_UP 表示 L1 是启动的，也即网线插着 MTU1500 是指什么意思呢？是哪一层的概念？ 最大传输单元 MTU 为 1500，这是以太网的默认值。 MTU 是二层 MAC 层的概念。 MAC 层有 MAC 的头，以太网规定连 MAC 头带正文合起来，不允许超过 1500 个字节。 qdisc pfifo_fast 是什么意思呢？排队规则。规定数据包如何进出的。有pfifo, pfifo_fast. 额外知识一个C类地址最大能表示256个IP地址，为什么最多能连254台主机？因为存在广播地址和网络地址（不可用） 如何得出网络地址、广播地址？ 子网掩码和IP地址的进行二进制“与”运算，得出出网络地址 网络地址二进制后连续的0栋变成1就是广播地址 如何计算子网数、主机数？ 子网数=2^（实际网络号位数 – 地址类型网络号位数） 主机数=2^主机号 为什么 子网掩码 必须由连续的 1 和 0 组成？因为继承的连续性，证明这个子网是这个网段的，不认错爸知乎回答：https://www.zhihu.com/question/285680797 小结 可以使用ifconfig或ip addr查看地址 IP地址分为五大类，后使用CIDR重构规则，以解决地址耗尽 CIDR聚合多个子网地址合成一个超网地址以减少核心路由器运载，使能够更自由的分配主机数 根据子网掩码可以得出IP地址的网络号和主机号，在CIDR中还能得出网络地址、广播地址、子网数和主机数等 scope表示一个范围，它是ip地址的属性，后面要是global表示该网卡对外通信，host对内通信]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【网络协议】笔记二 | 网络分层的真实含义]]></title>
    <url>%2F2018%2F07%2F24%2F%E3%80%90%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%91%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%9A%84%E7%9C%9F%E5%AE%9E%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[太复杂，就分工 知识点 网络分层 数据包处理程序 TCP握手的背后 网络为什么分层？因为是个复杂的程序都要分层，这是程序设计的要求, 涉及到架构和设计模式的问题，分层是各个模块业务逻辑的职责划分。 处理网络数据包的程序是如何工作的？客户端和服务器就像没有天桥的双子楼，要从A座的24层到达B座24层就得先下楼梯再上楼梯 发送请求：封包 点击网页，发起HTTP请求,浏览器使用端口号发送。 添加TCP头，记录下源端口号。浏览器给出目的端口号，一般为80端口。 添加IP头，记录下源IP地址和目标IP地址。 添加MACtou，记录源MAC地址和目标MAC地址，目标MAC地址如果不知道，需要通过一定的协议处理过程（玄奘西行），找到MAC地址。 网口发出。 接受请求：拆包 经过网口。 判断mac地址是否是自己，不是则不接收。 判断IP地址是否是自己的，不是则转发。 判断地址是TCP还是UDP进行不同的逻辑处理。假设这个地址是 TCP的，则会调用process_tcp(buffer)。这时候，Buffer里面没有三层的头，就需要查看四层的头，看这是一个发起，还是一个应答，又或者是一个正常的数据包，然后分别由不同的逻辑进行处理。如果是发起或者应答，接下来可能要发送一个回复包；如果是一个正常的数据包，就需要交给上层了。判断哪个应用处理，在四层的头里面有端口号，不同的应用监听不同的端口号。 浏览器解析HTML，显示页面。 TCP 在三次握手的时候，IP 层和 MAC 层在做什么呢?TCP 发送每一个消息，都会带着 IP 层和 MAC 层了。因为，TCP 每发送一个消息，IP 层和 MAC 层的所有机制都要运行一遍。记住：只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。所以，对 TCP 协议来说，三次握手也好，重试也好，只要想发出去包，就要有 IP 层和 MAC 层，不然是发不出去的。如同跨越没有天桥的双子楼，从A栋的4楼跑去B栋的4楼都需要经过下楼、上楼的步骤，把4楼以下的楼层跑一次。 知识复盘网络为什么要分层？太复杂 处理网络数据包的程序是如何工作的？像个没有天桥的双子楼，到达服务器就要先封包下楼再拆包上楼 TCP在三次握手的时候，IP层和MAC层在做什么？IP层和MAC层所有机制都要运行一遍，封包下楼、拆包上楼 小结 网络程序分层处理，下楼封包、上楼拆包 MAC地址对上就上楼，IP地址不对就从楼中丢出去 楼层（TCP）与对面楼层之间不能飞跃而过，该怎么走就怎么走]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【网络协议】笔记一 | 为什么要学习网络协议？]]></title>
    <url>%2F2018%2F07%2F23%2F%E3%80%90%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%91%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[为了打造互联网世界的通天塔 知识点 协议三要素 常用的网络协议 网络数据包结构 一次玄奘西行 为什么要学习网络协议？只有通过网络协议，才能使一大片机器互相协作、共同完成一件事。 协议三要素例如编写代码打印“hello world”也是人类和计算机沟通的协议，需要经过编译成机器可识别文件执行 。不同的计算机之间必须使用相同的网络协议才能进行通信。语法：“如何讲”，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。语义：“讲什么”，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。顺序：“讲啥先”，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值。 比如浏览器上展示网页内容：它之所以能够显示缤纷多彩的页面，是因为它收到了一段来自 HTTP协议的“东西”，例如网易考拉，格式如下： 12345678910HTTP/1.1 200 OKDate: Tue, 27 Mar 2018 16:50:26 GMTContent-Type: text/html;charset=UTF-8Content-Language: zh-CN&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;base href="https://pages.kaola.com/" /&gt;&lt;meta charset="utf-8"/&gt; &lt;title&gt; 网易考拉 3 周年主会场 &lt;/title&gt; 首先，符合语法。只有按照上面那个格式来，浏览器才认。例如，上来是状态，然后是首部，然后是内容。然后，符合语义。就是要按照约定的意思来。例如，状态 200，表述的意思是网页成功返回。如果不成功，就是我们常见的“404”。最后，符合顺序。点击浏览器，就是发送出一个 HTTP 请求，然后才有上面那一串 HTTP 返回的东西。浏览器显然按照协议商定好的做了，最后一个五彩缤纷的页面就出现在你面前了。 常用的网络协议DNS协议、HTTP协议、HTTPS协议、TCP/IP协议、IP协议、DHCP协议、ARP协议**等**比如网上的一次点击购物的请求包含： 图上5层，从下往上一层层封装：第一层：是什么第二层：啥样式 DNS、HTTP、HTTPS 所在的层我们称为应用层。 经过应用层封装后，浏览器会将应用层的包交给下一层去完成，通过socket 编程来实现 第三层：咋处理 传输层有两种协议，一种是无连接的协议UDP（发短信），一种是面向连接的协议TCP（打电话） TCP 协议里面会有两个端口，一个是浏览器监听的端口，一个是电商的服务器监听的端口。操作系统往往通过端口来判断，它得到的包应该给哪个进程。传输层封装完毕后，浏览器会将包交给操作系统的网络层 第四层：交给谁 网络层的协议是 IP 协议。 IP 协议里面会有源 IP 地址，即浏览器所在机器的 IP 地址和目标 IP 地址，也即电商网站所在服务器的 IP 地址。 第五层：先去哪 操作系统根据IP这个门牌号判断是内地人还是外地人的，去外地就要经过网关。 而操作系统启动的时候，就会被 DHCP 协议配置 IP 地址，以及默认的网关的 IP 地址 。 操作系统发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理MAC地址。 于是操作系统将 IP 包交给了下一层，也就是MAC 层。 由于这个包里面是有 MAC 地址的，因而它能够到达网关。 网关往往是一个路由器，到某个 IP 地址应该怎么走，这个叫作路由表。 玄奘西行 一次购物请求的整个过程如同玄奘西行，不断经过国家的城关（路由器）；每个城关连着两个国家（局域网），一旦跨越城关，就需要拿出通关文牒（数据包中包含源IP地址）并询问接下来该如何走，每个城关都知道下一个城关怎么走； 当城关通过通关文牒知道目的地（目标IP）在自己邻接的国家中，就好发起通告（广播）寻找，然后得到回复（目标MAC地址），然后就可以到达天竺（目标服务器）了； 然后天竺确认你确实是找天竺的（在城关寻得的MAC地址对得上），再确认你寻的真经是在天竺的（IP地址对得上），最后让人寻真经给你（IP 头里会写上一层封装的是 TCP 协议，然后将其交给传输层，即TCP层）； 西行路上千难万险，因此到了得报个平安（仅仅是 TCP 层的一个说明，原路返回，如果过段时间还没回复，不断重发，知道平安到达的回复，tcp的三次握手）。 城关： 流程： 有IP地址为什么还需要MAC地址？IP地址可以变动，而MAC地址是唯一的。IP是个人地址，MAC是个人身份证，地址可以变更，但身份证不行。到达了个人地址还需要确认身份证，才能证明找的是本人。 当网络包到达一个城关的时候，可以通过路由表得到下一个城关的 IP 地址，直接通过 IP 地址找就可以了，为什么还要通过本地的 MAC 地址呢？ 局域网内IP地址是动态分配的，假如我是192.168.2.100，如果我下线了，可能IP就分配给了另一台电脑。IP和设备并不总是对应的，这对通信就产生了问题，但是MAC地址不同，MAC地址和设备是一一对应且全球唯一的。所以局域网使用MAC地址通信没有问题。 历史遗留问题：早期的以太网只有交换机，没有路由器，以太网内通过MAC地址通信。后来才有了互联网，为了兼容原本的模式，采用了IP+MAC地址通信的方式。为啥不推到了重来呢？看看IPv6的处境你就知道了。所以是先有MAC地址后有的IP，IP的提出主要还是因为MAC地址本身的缺陷，这个问题换成有了MAC为何还要IP地址也很有意思。 第一：MAC地址本身的缺陷：因为MAC地址是硬件提供商写在网卡中的，MAC地址虽然唯一但是不能表明用户在整个互联网中的位置，除非维护一个超级大MAC地址对应表，那寻址效率肯定爆炸。但是IP地址解决了这个问题，因为IP地址是网络提供商给你的，所以你在哪里整个网络都是知道的。第二：安全问题：获取MAC地址是通过ARP协议来完成的，如果只用MAC地址通信，那么广播风暴是个难题。 猜想：如果哪天每人一个固定的IPv6地址，那么MAC地址+IPv4的模式是不是可以被替换了？ 其实手机通过数据上网就是一个通过类似mac寻址的一个网络。在移动网络中是允许你移动的，这是由于基站会记录你的位置信息。并且核心网与公网的通信是通过ip来实现的，而在手机和基站间的通信是通过类似mac的一个唯一码实现的。并且移动网络整体建设成本比互联网的成本高很多，消费也高很多。 为什么mac地址是全世界唯一的？网卡MAC码是由全球惟一的一个固定组织来分配的，未经认证和授权的厂家无权生产网卡。每块网卡都有一个固定的卡号，并且任何正规厂家生产的网卡上都直接标明了卡号，一般为一组12位的16进制数。其中前6位代表网卡的生产厂商。后面的位数是设备号。当然在操作系统级别改Mac地址又是一种说法。 知识复盘为什么要学习网络协议？能使一大片机器互相协作、共同完成一件事 协议三要素是什么？语法、语义、顺序 一个网络请求包都包括啥？是什么、啥样式、咋处理、交给谁、先去哪 如何形象描述一次网络请求？玄奘西行 有IP地址为什么还需要MAC地址？ IP是个人地址，MAC是个人身份证 为什么mac地址是全世界唯一的 网卡MAC码是由全球惟一的一个固定组织来分配的 小结 机器之间只有达成协议才能通信协作 一次网络请求如同一次玄奘西行，长途跋涉 ————————————————————————————————————————以上笔记学习于“极客时间”APP专栏，部分内容选自专栏评论。]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 简单关键字爬取微信公众号文章]]></title>
    <url>%2F2018%2F06%2F26%2FPython-%E7%AE%80%E5%8D%95%E5%85%B3%E9%94%AE%E5%AD%97%E7%88%AC%E5%8F%96%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[记录一次爬虫作业项目 序爬取目标：微信公众号“纵梦广科”中“表白墙”（可选“吐槽墙”）的文章爬取字段：表白对象、表白内容爬取缘由：分析“表白墙”上的同学什么说得多的词爬取工具：matplotlib、wordcloud、jieba爬取结果: “表白墙”文章160篇爬取收获：简单爬取公众号文章、简单生成词云爬取注意： 因为爬取内容可以简洁地直接保存txt文本进行绘画词云分析，所有并没有存入数据库 本项目代码不具有可复用性，无论是登录的cookie还是文章的页数都需要重新手动获取输入 代码中cookie的值太长了，都在一行不方便阅读，于是做了分行，可以根据个人喜好选择 本代码通用于爬取公众号文章的标题和url，如需要爬取文章内容则需要手动更改爬取规则 token的值是爬取的公众号的标识符，如果更换公众号就需要更改该值 本项目代码因为“表白墙”与“吐槽墙”网页结构相同，因此可以自行选择输入“表白墙”或“吐槽墙”进行爬取 词云图在本文档后面 获取cookie等操作步骤在本文最后 ps:在参考文章中的例子是直接搜索公众号全部内容文章的，我测试过这样爬取全部的话只能爬几页就被提示”操作太频繁“而无法爬取，但换成关键字”query”搜索的话没有出现问题，目前本代码爬取”表白墙“32页并没有本禁止。本来还尝试如何避免封装爬取全部文章但没有成功，但如果关键字是空白符或者其他标点符号的话也能获取大部分文章 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115# -*- coding: utf-8 -*-import requestsfrom PIL import Imagefrom lxml import etreeimport timeimport randomimport matplotlib.pyplot as pltimport numpy as npfrom wordcloud import WordCloudimport jieba# 使用Cookie，跳过登陆操作headers = &#123; "Cookie": "noticeLoginFlag=1; remember_acct=820605644%40qq.com; " "ua_id=F89e6CvMPIib8tkPAAAAAE8A9_O5KrS5oMM390XQRHI=; mm_lang=zh_CN; pgv_pvi=1996118016; " "noticeLoginFlag=1; remember_acct=820605644%40qq.com; pgv_si=s2063726592; ticket_id=gh_86437b3d3630; " "cert=3RRm40LWsECquCbg_jx5lQTMXRR4M0tN; rewardsn=; wxtokenkey=777; " "uuid=652947b257247d453cd64dc13a5daf0b; ticket=d19dbee738a3be7f0806c8a5f726b8d8cac125f6; " "data_bizuin=3555601673; bizuin=3551846274; " "data_ticket=eeN9lRUD61DWiiLZEJyFKGoi70SoJ2dB1BoNi4PnSvNaf6R3jA83ZYyEI1y3LaOU; " "slave_sid" "=elBZTHhvYlc0VmNnYTM0SnZ6Wl9DaGZTNWh0M0VZVHlxUDBfWHNUW" "jFVbEpOcFpmWEpuNUFXTEdGRWI5a3p6OGhrUWYweExnNjN2d0xMUWEwTVlLVWxIWk9mXzhzbkYxWndCQUVYTm" "l1UnVxYlNWbmR3Q09VT2pMbEFMZDNhOFhXTnRnMlpDbDhvYzZWN2hQ;" " slave_user=gh_86437b3d3630; xid=a5467f49610c64af7a7022c6a4596f40; " "openid2ticket_oCS3u05exHidsZqiS_3Q8Yn-YtYI=JjxfUwXvqw0VBHJhW5TvmrOn8W5QMp/ReaanapVptWI=", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) " "Chrome/65.0.3325.162 Safari/537.36",&#125;# 词云def get_word(f): """ 创建词云图片，默认样式 :param f: :return: """ text_from_file_with_apath = open(f, 'rb').read().decode('utf-8') wordlist_after_jieba = jieba.cut(text_from_file_with_apath, cut_all=True) print(wordlist_after_jieba) wl_space_split = " ".join(wordlist_after_jieba) alice_mask = np.array(Image.open("girl.jpg")) # 以数组的形式加载图画 my_wordcloud = WordCloud(font_path="simhei.ttf", # 设置字体 background_color="white", # 背景颜色 max_words=2000, # 词云显示的最大词数 mask=alice_mask, # 设置背景图片 max_font_size=100, # 字体最大值 random_state=42, margin=2, # 设置图片默认的大小,但是如果使用背景图片的话,那么保存的图片大小将会按照其大小保存,margin为词语边缘距离 ).generate(wl_space_split) plt.imshow(my_wordcloud) plt.axis("off") plt.show()def get_info(url): """ 获取文章中的吐槽对象和吐槽内容 :param url: :return: """ res = requests.get(url, headers=headers) selector = etree.HTML(res.text) names = selector.xpath('// *[ @ id = "js_content"] // section / section[2] / section / span / span / text()') contents = selector.xpath('// *[ @ id = "js_content"] // section / section[2] / section / text()') with open('name.txt', 'ab+') as f: for s in names: f.write(s.strip().encode('utf-8')) with open('content.txt', 'ab+') as f: for s in contents: f.write(s.strip().encode('utf-8')) return 'content.txt', 'name.txt'def get_list(url, input_name, post_num): """ 获取每页搜索结果的json中文章的标题和url :param url: :return: """ for num in range(post_num): data = &#123; "token": 1111467131, "lang": "zh_CN", "f": "json", "ajax": "1", "action": "list_ex", "begin": num * 5, "random": 0.040206335386987035, "count": "5", "query": input_name, "fakeid": "MzAwMzExNTQyNQ==", "type": "9", &#125; # 使用get方法进行提交 content_json = requests.get(url, headers=headers, params=data).json() # 返回了一个json，里面是每一页的数据 for item in content_json["app_msg_list"]: # 提取每页文章的标题及对应的url print(item["title"], "url:", item["link"]) f1, f2 = get_info(item["link"]) time.sleep(random.randint(0, 30)) return f1, f2# 目标urlif __name__ == "__main__": input_name = "表白墙" # 表白墙或吐槽墙任选其一 url = "https://mp.weixin.qq.com/cgi-bin/appmsg" f1, f2 = get_list(url, input_name, post_num=32) get_word(f1) # 创建词云 get_word(f2) 图片公众号截图： 表白内容词云： 表白对象词云： 操作步骤1、拥有一个微信个人订阅号，附上登陆和注册链接。微信公众平台 2、好在之前无聊注册过一次，所以就可以直接登陆操作。没有注册的童鞋可以用自己的微信号注册一下，过程十分简单，在此就不赘述了 3、登陆之后，点击左侧菜单栏“管理”-“素材管理”。再点击右边的“新建图文素材” ​弹出一个新的标签页，在上面的工具栏找到“超链接”并点击 弹出了一个小窗口，选择“查找文章”，输入需要查找的公众号点击之后，可以弹出该公众号的所有历史文章关键字搜索、页数 查看cookie 查看token 本文部分参考该博友的文章：https://blog.csdn.net/wnma3mz/article/details/78570580]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 设置首页隐藏指定文章]]></title>
    <url>%2F2018%2F06%2F12%2FHexo-%E8%AE%BE%E7%BD%AE%E9%A6%96%E9%A1%B5%E9%9A%90%E8%97%8F%E6%8C%87%E5%AE%9A%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[有时候我们可能只想在首页显示关于编程之类的内容，而个人日记之类的文章放在其他分类之下而不在首页显示。可以从、分类、标签、归档中查看文章。 自定义front-matter的参数例如，自定义添加一个notshow参数，值为true，用来提供判断 123456789---title: 《好好学习》—黄金思维圈date: 2018-06-12 11:45:43tags:- readcategories:- readnotshow: true--- front-matter就是每次hexo new “post_name”创建的文章里面的开头。创建的文章存放在hexo根目录下的：source_posts中 修改主题的index.swig主题可能各不一样，但原理都是一样的，我拿我使用的next主题来示范。路径：Hexo\themes\next\layout\index.swig 1234567891011121314151617181920212223&#123;% extends '_layout.swig' %&#125;&#123;% import '_macro/post.swig' as post_template %&#125;&#123;% import '_macro/sidebar.swig' as sidebar_template %&#125;&#123;% block title %&#125;&#123;&#123; config.title &#125;&#125;&#123;% if theme.index_with_subtitle and config.subtitle %&#125; - &#123;&#123;config.subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125;&#123;% block page_class %&#125; &#123;% if is_home() %&#125;page-home&#123;% endif -%&#125;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;section id="posts" class="posts-expand"&gt; &#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125; &lt;/section&gt; &#123;% include '_partials/pagination.swig' %&#125;&#123;% endblock %&#125;&#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125;&#123;% endblock %&#125; 修改这里： 123456789&#123;% block content %&#125; &lt;section id="posts" class="posts-expand"&gt; &#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125; &lt;/section&gt; &#123;% include '_partials/pagination.swig' %&#125;&#123;% endblock % 改成： 1234567891011&#123;% block content %&#125; &lt;section id="posts" class="posts-expand"&gt; &#123;% for post in page.posts %&#125; &#123;% if post.notshow != true %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/section&gt; &#123;% include '_partials/pagination.swig' %&#125;&#123;% endblock %&#125; 在for循环迭代文章中判断文章中的属性notshow，如果不为true就打印出文章。所以在需要隐藏的文章front-matter中添加notshow:true就可以了。 添加自定义菜单比如我想在菜单栏添加一个“阅读”选项，但又不想新建自己一个页面，于是可以直接使用分类的页面。创建新文章的时候直接指定categories: read配置 123456789---title: 《好好学习》—黄金思维圈date: 2018-06-12 11:45:43tags:- readcategories:- readnotshow: true--- 在git中使用hexo g命令，hexo会在根目录/public/categrises下自动生成分类中的阅读文件夹然后，配置主题配置文件themes/_config.yml中添加以下代码（#号后为注释内容） 123456menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th read: /categories/read #指定分类中阅读的路径]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好学习》—黄金思维圈]]></title>
    <url>%2F2018%2F06%2F12%2F%E3%80%8A%E5%A5%BD%E5%A5%BD%E5%AD%A6%E4%B9%A0%E3%80%8B%E2%80%94%E9%BB%84%E9%87%91%E6%80%9D%E7%BB%B4%E5%9C%88%2F</url>
    <content type="text"><![CDATA[在古典老师的《超级个体》上，我接触到了2W1H的概念，然后在《结构思考力》中，我认识到了2W1H在工作中的分析问题的本质的用法,，而在《好好学习》中的“黄金思维圈”中，我更加清楚知道了，生活中做的每一件事都可以用2W1H去进行思考，也就是说善于问“为什么”，这样能够更好地看透问题的本质。 黄金思维圈—我们看问题方式的三个层次第一层次是what层次：事情的表象，我们具体做的每一件事 第二层次是how层次：我们如何实现我们想要做的事 第三层次是why层次：我们为什么要这么做 本章其他内容应聘者对于过去工作进行介绍 what：很多应聘者思考问题停留在what层面，就是只看到问题的表象 why：技术层面的时候有很多成熟的方法，给予时间训练就能提高，而思维方式的问题，因为涉及很多底层的假设和思维模式，如果没有一定的基础是难以改变的。 how：不是仅仅局限在工作内容本身，还能清晰第认识这个工作是在什么背景格局下产生的，为什么要完成这个工作，完成这个工作的关键是什么，突破口是什么….. 销售的最高境界销售你的价值观，也就是销售你的why——你为什么存在。 关键语句伪需求看到的是需求的what层面，而真实的需求是要在what的表象之后挖掘到真正的why。 黄金思维圈最大的价值：透过问题的表象看到问题的本质 抓住why的本质，激发how的创意 引用《第五项修炼》：每个人不能只 囿于自己的岗位，觉得只做好分内之职就可以了，要对职位之间相互关联产生的结果富有一定责任。]]></content>
      <categories>
        <category>read</category>
      </categories>
      <tags>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Flask】flask核心机制：current_app]]></title>
    <url>%2F2018%2F06%2F10%2Fflask%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9Acurrent-app%2F</url>
    <content type="text"><![CDATA[加深了对于Flask中current_app的理解，弥补了Miguel Grinberg的教程略过的知识点。 原文地址:Flask核心机制：current_app 核心知识 AppContext手动、自动入栈 LocalStack是线程隔离的栈结构 current_app是线程、协程隔离对象 LocalProxy是获取当前线程隔离的代理对象 flask中经典错误 working outside application context错误：working outside application contex原因：在没有获取到应用上下文的情况下，进行了上下文操作。代码： 123456from flask import Flask, current_appapp = Flask(__name__)a = current_appd = current_app.config['DEBUG'] 运行： AppContext、RequestContext、Flask与Request之间的关系AppContext: 应用上下文，是对flask一切对象的封装RequestContext: 请求上下文，是对request请求对象的封装current_app: 类型是LocalProxy 像全局变量一样工作，但只能在处理请求期间且在处理它的线程中访问 返回的栈顶元素不是应用上下文，而是flask的应用实例对象 应用上下文的封装=flask核心对象+和外部协作对象（再flask封装对象上再添加push、pop等）（请求上下文同理）代码：F12进入current_app 1234567# context locals_request_ctx_stack = LocalStack()_app_ctx_stack = LocalStack()current_app = LocalProxy(_find_app)request = LocalProxy(partial(_lookup_req_object, 'request'))session = LocalProxy(partial(_lookup_req_object, 'session'))g = LocalProxy(partial(_lookup_app_object, 'g')) current_app与reques：current_app和reques都是设计模式中代理设计的代理对象，指向flask核心对象和reques的请求类 详解flask上下文与出入栈在pycharm的flask项目中可以通过：External Libraries-&gt;site-packages-&gt;flask-&gt;ctx.py可以看到源码的实现ctx.py中有AppContext、RequestContext两个函数，都实现了push()和pop()AppContext：123456789101112131415161718192021222324252627282930313233343536373839class AppContext(object): """The application context binds an application object implicitly to the current thread or greenlet, similar to how the :class:`RequestContext` binds request information. The application context is also implicitly created if a request context is created but the application is not on top of the individual application context. """ def __init__(self, app): self.app = app self.url_adapter = app.create_url_adapter(None) self.g = app.app_ctx_globals_class() # Like request context, app contexts can be pushed multiple times # but there a basic "refcount" is enough to track them. self._refcnt = 0 def push(self): """Binds the app context to the current context.""" self._refcnt += 1 if hasattr(sys, 'exc_clear'): sys.exc_clear() _app_ctx_stack.push(self) appcontext_pushed.send(self.app) def pop(self, exc=_sentinel): """Pops the app context.""" try: self._refcnt -= 1 if self._refcnt &lt;= 0: if exc is _sentinel: exc = sys.exc_info()[1] self.app.do_teardown_appcontext(exc) finally: rv = _app_ctx_stack.pop() assert rv is self, 'Popped wrong app context. (%r instead of %r)' \ % (rv, self) appcontext_popped.send(self.app) flask在RequestContext入栈前会检查另外一个AppContext的栈的情况，如果栈顶元素为空或者不是当前对象，就会把AppContext推入栈中，然后RequestContext才进栈。LocalStack作用是线程隔离LocalProxy 的作用就是可以根据线程/协程返回对应当前协程/线程的代理对象，也就是说 线程 A 往 LocalStack中塞入 A 线程 B 往 LocalStack 中塞入 B 无论在是什么地方，调用LocalProxy， 线程 A 永远取到得是 A，线程 B 取到得永远是 B 有关Local、LocalStack的详解可以参考：http://python.jobbole.com/87738/ 这就是在 Flask 中可以在代码中直接使用 request、current_app 这样的变量的底层原因。 例如：过程就好比导游与游客。 导游-&gt;AppContext 游客-&gt;RequestContext 工作-&gt;push 消费-&gt;push 向导-&gt;current_app 游玩-&gt;request 旅程-&gt;LocalStack 每批游客都需要一位导游作为这批游客的专属向导，人生地不熟如果没有向导就麻烦了，因此游客开始去游玩前需要有导游带团。在这旅程中，导游和游客虽然分别是工作和消费，但导游（对象:栈顶元素）的任务就是给游客提供向导（属性:app），不提供其他服务，而游客负责游玩。当游客结束这旅程的同时导游的任务也完成（两个栈中的元素会被弹出）了。 手动AppContext进栈代码： 123456789from flask import Flask, current_appapp = Flask(__name__)# flask应用实例入栈ctx = app.app_context()ctx.push()a = current_appctx.pop() 运行：注意：但最终current_app得到的栈顶元素不是应用上下文，而是flask的应用实例对象!F12进入查看源码12345678910current_app = LocalProxy(_find_app)``` 查看**_find_app**函数``` def _find_app(): top = _app_ctx_stack.top if top is None: raise RuntimeError(_app_ctx_err_msg) return top.app 可以发现最后返回的是top对象中的app。reques和session同理，不过传多一个字符串进行查找。 flask自动入栈如果是在一个请求中直接使用current_app对象是不用手动把AppContext推入栈中的。如之前所说RequestContext入栈前会检查另外一个AppContext的栈的情况，这个操作会由flask帮你完成。 手动进栈存在的价值单元测试不在reques请求环境中执行，需要手动AppContext进栈。离线应用。例如待会介绍的异步邮箱例子。 flask上下文与with语句可以使用with 来实现自动入栈和出栈，比上面手动push、pop的更优雅，因为在AppContext中已实现两个特殊方法enter、exit，也被称为“魔法方法”，凡是实现了这两个特殊方法的对象都可以被with所使用。123456def __enter__(self): self.push() return selfdef __exit__(self, exc_type, exc_value, tb): self.pop(exc_value) python with的使用这里不详细讨论,在flask中注意的是： 实现了上下文协议的对象使用with with被称做上下文管理器 只要实现enter、exit就是实现上下文协议 上下文表达式（app.app_context()）必须返回一个上下文管理器（AppContext） exit最后三个参数记录发生异常时的信息，exit返回bool类型，返回true表示正常，false会抛出异常，没有返回值默认为false 代码： 123456from flask import Flask, current_appapp = Flask(__name__)with app.app_context(): a = current_app 运行：上图中全局变量a在with的作用域中的值为flask应用的实例对象main,当with关闭后就变成了LocalProxy unbound flask中实际应用发送密码重置电子邮件123456789101112131415161718from flask import render_templatefrom app import app# ...def send_password_reset_email(user): """ 令牌，生成密码重置电子邮件 """ token = user.get_reset_password_token() # 调用email.py中的send_email函数 send_email('[Microblog] Reset Your Password', sender=app.config['ADMINS'][0], recipients=[user.email], text_body=render_template('email/reset_password.txt', user=user, token=token), html_body=render_template('email/reset_password.html', user=user, token=token)) 异步电子邮件email.py: 123456789101112131415161718192021222324from threading import Threadfrom flask import current_appfrom flask_mail import Messagefrom app import maildef send_async_email(app, msg): with app.app_context(): mail.send(msg)def send_email(subject, sender, recipients, text_body, html_body, attachments=None, sync=False): msg = Message(subject, sender=sender, recipients=recipients) msg.body = text_body msg.html = html_body if attachments: # 附件 for attachment in attachments: msg.attach(*attachment) if sync: # 是否异步 mail.send(msg) else: Thread(target=send_async_email, args=(current_app._get_current_object(), msg)).start() 1. send_async_email()mail.send()方法需要访问电子邮件服务器的配置值，而这必须通过访问应用属性的方式来实现。 使用with app.app_context()调用创建的应用上下文使得应用实例可以通过来自Flask的current_app变量来进行访问。 2. send_email()：在send_email()函数中，应用实例作为参数传递给后台线程，后台线程将发送电子邮件而不阻塞主应用程序。在作为后台线程运行的send_async_email()函数中直接使用current_app将不会奏效，因为current_app是一个与处理客户端请求的线程绑定的上下文感知变量。在另一个线程中，current_app没有赋值。直接将current_app作为参数传递给线程对象也不会有效，因为current_app实际上是一个代理对象，它被动态地映射到应用实例。因此，传递代理对象与直接在线程中使用current_app相同。我需要做的是访问存储在代理对象中的实际应用程序实例，并将其作为app参数传递。 current_app._get_current_object()表达式从代理对象中提取实际的应用实例，所以它就是我作为参数传递给线程的。 current_app._get_current_object()作用是获取本线程的应用实例以作为参数传递给其他线程使用，应用实例就是_find_app中返回的top.app 因为current_app = LocalProxy(_find_app)中LocalProxy作用是获得线程隔离对象，在上面详解flask上下文与出入栈有说到 所以哪怕其他线程获得了current_app这个变量，他的线程隔离中也没有任何东西 而把本线程中的属性传递给其他线程却不关线程隔离的事，所以其他线程可以使用应用实例 代码：原本是要调用_find_app才得到top.app的，现在通过current_app._get_current_object()不经过_find_app也可以获得，无关线程隔离 小结 以线程ID号作为key的字典-&gt;Local-&gt;LocalStack AppContext RequestContext -&gt; LocalStack Flask -&gt; AppContext Request -&gt; RequestContext (LocalStack.top = AppContext top.app=Flask) -&gt; current_app (LocalStack.top = RequestContext top.request=Request) -&gt; request]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之NexT主题 icon一直显示默认样式]]></title>
    <url>%2F2018%2F06%2F09%2Fnext%E4%B9%8Bicon%2F</url>
    <content type="text"><![CDATA[今天配置了一下午的next主题，也遇到了一些问题，主要还是官方教程和网上的教程贴都是按照以前的next版本的，印象深刻的就是icon。无论网上还是官方文档有关于icon的图标设置都差不多如下12345678 GitHub: https://github.com/yourname 邮箱: mailto:test@gamil.comsocial_icons: enable: true icons_only: false transition: false GitHub: github 邮箱: envelope 但在最新的next中这样配置会变成这样子：并且如果 icons_only: true 的话也会变成这样正确配置123456 GitHub: https://github.com/yourname || github 邮箱: mailto:test@gamil.com || envelopesocial_icons: enable: true icons_only: false transition: false 我还是在网上查找后才解决，这次附上了图。其实主题配置文件_config.yml已经有注释的了，但新手刚刚接触的话可能直接按照官方或者网上教程来，而忽视了注释。嗯。。。hexo的上传图片也是个不太舒服的操作。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python sort与sorted]]></title>
    <url>%2F2018%2F06%2F09%2FPython%20sort%E4%B8%8Esorted%2F</url>
    <content type="text"><![CDATA[了解sort与sorted的排序 语法sort语法：python2:iterable.sort(cmp[, key[, reverse]])python3:iterable.sort(, key=None, reverse=False)sorted 语法：python2:sorted(iterable[, cmp[, key[, reverse]]])python3:sorted(iterable, , key=None, reverse=False) 参数iterable – 可迭代对象。cmp(python3中已经取消) – 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。在对一些字符串排序时，可以用key=str.lower来忽略大小写的排序，或者是用key=len进行基于字符串长度的排序。reverse–排序规则. reverse = True 或者 reverse = False(默认)。（cmp和key可以使用lambda表达式） 区别sort是成员函数，sorted是built-in内建函数（被解释器所调用）sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作 注意：在Python3版本中，sort和sorted已经取消了cmp，也就是说安装原先的方法已经无法满足根据两个参数的比较来排序的需求，但可以使用cmp_to_key 例1： 12345678&gt;&gt;&gt; students = [('danny', 'male', 15), ('Tom', 'male', 12), ('Jerry','female', 10)]&gt;&gt;&gt; sorted(students,key=lambda s: s[2]) #按照年龄来排序[('Jerry', 'female', 10), ('Tom', 'male', 12), ('danny', 'male', 15)]&gt;&gt;&gt; students#使用sorted，原来的列表没有变化[('danny', 'male', 15), ('Tom', 'male', 12), ('Jerry', 'female', 10)]&gt;&gt;&gt; students.sort(key=lambda s: s[2])&gt;&gt;&gt; students#使用了元素的函数sort自身发生了改变[('Jerry', 'female', 10), ('Tom', 'male', 12), ('danny', 'male', 15)] 例2：字符串排序，排序规则：小写-大写-奇数-偶数 123&gt;&gt;&gt; s = 'asdf234GDSdsf23'&gt;&gt;&gt; print("".join(sorted(s, key=lambda x: (x.isdigit(),x.isdigit() and int(x) %2 == 0,x.isupper(),x))))addffssDGS33224 1.x.isdigit()检测字符串是否只由数字组成，排序把数字放在右边,字母放在左边.2.x.isdigit() and int(x) % 2 == 0的作用是保证奇数在右，偶数在左。3.x.isupper()的作用是在前面基础上,保证字母小写在右大写在左.4.最后的x表示在前面基础上,对所有类别数字或字母排序。例3：要求1.正数在前负数在后 2.整数从小到大 3.负数从大到小 12345678&gt;&gt;&gt; list_a=[7, -8, 5, 4, 0, -2, -5]&gt;&gt;&gt; sorted(list_a,key=lambda x:(x&lt;0,abs(x)))[0, 4, 5, 7, -2, -5, -8]&gt;&gt;&gt; list_a[7, -8, 5, 4, 0, -2, -5]&gt;&gt;&gt; list_a.sort(key=lambda x:(x&lt;0,abs(x)))&gt;&gt;&gt; list_a[0, 4, 5, 7, -2, -5, -8] 先按照正负排先后，再按照大小排先后。 例子4使用cmp：来源牛客网编程题目原地址 https://www.nowcoder.com/practice/a6a656249f404eb498d16b2f8eaa2c60?tpId=85&amp;&amp;tqId=29898&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking 题目内容如下 设有n个正整数，将他们连接成一排，组成一个最大的多位整数。如:n=3时，3个整数13,312,343,连成的最大整数为34331213。如:n=4时,4个整数7,13,4,246连接成的最大整数为7424613。输入描述:有多组测试样例，每组测试样例包含两行，第一行为一个整数N（N&lt;=100），第二行包含N个数(每个数不超过1000，空格分开)。输出描述:每组数据输出一个表示最大的整数。示例1输入 212 12347 13 4 246输出 123127424613 python2： 12345678def cmp(a, b): ab = int(a+b) ba = int(b+a) return 1 if ab &gt; ba else -1 num = input() l=raw_input().split(' ') l.sort(cmp, reverse=True) print int(''.join(l)) python3： 1234567891011from functools import cmp_to_key #导入使用cmp_to_keydef cmp(a, b): ab = int(a+b) ba = int(b+a) return 1 if ab &gt; ba else -1 num = input() l=input().split(' ') #python3中把python2的row_input(str)和iuput(int)结合到inptu(str)一起l.sort(key=cmp_to_key(cmp), reverse=True) print(int(''.join(l))) python3中sort和sorted取消了对cmp的支持，并且key接受一个函数，这个函数只接受一个元素，而当需要两个元素来进行比较时可以使用functools.cmp_to_key。 后记key 和 reverse 比一个等价的 cmp 函数处理速度要快。这是因为对于每个列表元素，cmp 都会被调用多次，而 key 和 reverse 只被调用一次可选参数key还可以在内置函数min()和max()中起作用。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
