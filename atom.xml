<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The program life</title>
  
  <subtitle>the panic of choice</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://itfriends.xyz/"/>
  <updated>2018-07-30T16:57:42.345Z</updated>
  <id>http://itfriends.xyz/</id>
  
  <author>
    <name>淡然</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【架构】笔记二 | 架构设计的目的</title>
    <link href="http://itfriends.xyz/2018/07/31/%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E7%AC%94%E8%AE%B0%E4%BA%8C-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%9B%AE%E7%9A%84/"/>
    <id>http://itfriends.xyz/2018/07/31/【架构】笔记二-架构设计的目的/</id>
    <published>2018-07-30T16:56:21.000Z</published>
    <updated>2018-07-30T16:57:42.345Z</updated>
    
    <content type="html"><![CDATA[<p>为了收益最大化</p><a id="more"></a><h1 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h1><ul><li>架构设计的核心是分析复杂度</li><li>架构即是收益决策</li></ul><p>首先要明白的是，<strong>架构就是一种设计，一种设计思想</strong>。</p><h1 id="架构设计常见误区"><a href="#架构设计常见误区" class="headerlink" title="架构设计常见误区"></a>架构设计常见误区</h1><p><strong>因为框架很重要，所以要做框架设计</strong>-》正确的废话</p><ul><li>不做框架设计系统就跑不起来么？ 不然</li><li>做了框架设计就能提高开发效率么？ 不尽然</li><li>设计良好的架构能促进业务发展么？ 不好说</li></ul><p><strong>不是每个系统都要做框架设计吗</strong>-》知其然不知其所以然<br><strong>公司流程要求系统开发过程中必须有架构设计</strong>-》舍本逐末<br><strong>为了高性能、高可用、可扩展，所以要做框架设计</strong>-》画蛇添足</p><h1 id="架构设计的真正目的"><a href="#架构设计的真正目的" class="headerlink" title="架构设计的真正目的"></a>架构设计的真正目的</h1><p>架构也是为了应对软件系统复杂度而提出的一个解决方案，通过回顾架构产生的历史背景和原因，我们可以基本推导出答案：<strong>架构设计的主要目的是为了解决软件系统复杂度带来的问题</strong>。</p><p>明确了“<strong>架构设计是为了解决软件复杂度</strong>”原则后，很多架构上的困惑都可以很好回答。</p><p><strong>“这么多需求，从哪里开始下手进行架构设计呢？”</strong></p><ul><li>——通过熟悉和理解需求，识别系统复杂性所在的地方，然后针对这些复杂点进行架构设计。</li></ul><p><strong>“架构设计要考虑高性能、高可用、高扩展……这么多高 XX，全部设计完成估计要 1 个月，但老大只给了 1 周时间”</strong></p><ul><li>——架构设计并不是要面面俱到，不需要每个架构都具备高性能、高可用、高扩展等特点，而是要识别出复杂点然后有针对性地解决问题。</li></ul><p><strong>“业界 A 公司的架构是 X，B 公司的方案是 Y，两个差别比较大，该参考哪一个呢？”</strong></p><ul><li>——理解每个架构方案背后所需要解决的复杂点，然后才能对比自己的业务复杂点，参考复杂点相似的方案。</li></ul><p><strong>分析复杂度</strong><br><strong>分析复杂度</strong><br><strong>分析复杂度</strong></p><p><strong>当我们对任何一个系统无论是进行架构设计还是更改的时候，首先应识别其复杂度到底体现在哪里</strong></p><p>基于系统业务应用场景分析复杂度，分析复杂度是为了跟系统业务应用场景相贴合。</p><h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><p>比如要搭建一个“学生管理系统”，分析复杂度</p><ul><li><strong>性能</strong>：学校学生人数不多，访问频率不高，存储用 MySQL 完全能够胜任，缓存都可以不用，Web 服务器用 Nginx 绰绰有余。</li><li><strong>可扩展性</strong>：学生管理系统的功能比较稳定，可扩展的空间并不大，因此可扩展性也不复杂。</li><li><strong>高可用</strong>：学生管理系统即使宕机 2 小时，对学生管理工作影响并不大，因此可以不做负载均衡，更不用考虑异地多活这类复杂的方案了。但是，如果学生的数据全部丢失，修复是非常麻烦的，只能靠人工逐条修复，这个很难接受，因此需要考虑存储高可靠，这里就有点复杂了。我们需要考虑多种异常情况：机器故障、机房故障，针对机器故障，我们需要设计<br>MySQL 同机房主备方案；针对机房故障，我们需要设计 MySQL 跨机房同步方案。</li><li><strong>安全性</strong>：学生管理系统存储的信息有一定的隐私性，例如学生的家庭情况，但并不是和金融相关的，也不包含强隐私（例如玉照、情感）的信息，因此安全性方面只要做<br>3 个事情就基本满足要求了：Nginx 提供 ACL 控制、用户账号密码管理、数据库访问权限控制。</li><li><strong>成本</strong>：由于系统很简单，基本上几台服务器就能够搞定，对于一所大学来说完全不是问题，可以无需太多关注。</li></ul><p>对应架构如下:<br><img src="https://img-blog.csdn.net/20180730234909661?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>“<strong>复杂度</strong>”可以简单理解成“<strong>成本</strong>”,“<strong>复杂度带来的问题</strong>”就是“<strong>成本收益难度</strong>”，而“<strong>分析复杂度</strong>”就是“<strong>成本收益分析</strong>”，也就是说架构设计的目的是为了“<strong>收益最大化</strong>”</p><h1 id="架构设计过程"><a href="#架构设计过程" class="headerlink" title="架构设计过程"></a>架构设计过程</h1><p><strong>架构即决策</strong>，收益决策<br><strong>明确需求</strong>-&gt;<strong>分析复杂度</strong>-&gt;<strong>做出决策</strong>。</p><h1 id="知识复盘"><a href="#知识复盘" class="headerlink" title="知识复盘"></a>知识复盘</h1><h2 id="架构设计核心是什么？"><a href="#架构设计核心是什么？" class="headerlink" title="架构设计核心是什么？"></a>架构设计核心是什么？</h2><p>分析复杂度（成本收益分析）</p><h2 id="架构设计的目的是什么？"><a href="#架构设计的目的是什么？" class="headerlink" title="架构设计的目的是什么？"></a>架构设计的目的是什么？</h2><p>解决复杂度的问题（成本收益难度）</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>架构设计是为了解决软件复杂度</li><li>优秀的架构设计能更好地收益最大化</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了收益最大化&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://itfriends.xyz/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://itfriends.xyz/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【网络协议】笔记六 | 交换机与VLAN</title>
    <link href="http://itfriends.xyz/2018/07/30/%E3%80%90%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%91%E7%AC%94%E8%AE%B0%E5%85%AD-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%8EVLAN/"/>
    <id>http://itfriends.xyz/2018/07/30/【网络协议】笔记六-交换机与VLAN/</id>
    <published>2018-07-30T13:25:28.000Z</published>
    <updated>2018-07-30T13:27:51.266Z</updated>
    
    <content type="html"><![CDATA[<p>暂时还没有完全理解，笔记逻辑存在一些BUG</p><a id="more"></a><h1 id="核心知识点"><a href="#核心知识点" class="headerlink" title="核心知识点"></a>核心知识点</h1><ul><li>STP协议解决交换机环路问题</li><li>理解STR协议</li><li>使用VLAN解决广播域冲突</li></ul><p>宿舍使用一台交换机就完全没有问题了，但要是写字楼办公室的可以就需要多台交换机了。多台交换机连接起来，就形成稍微复杂的<a href="https://www.baidu.com/link?url=-rhoZtuBlnJJd17px1T5rCWQp_2wV50xqkgc59spWbWAVP9AO2BtfxLAHjzgaOX8ece-el-Z5imdzwBl05aEfbTdF3Fer3mUTXJgFInQxW8eMmiRqCMMjzYhZ5fKQskk&amp;wd=&amp;eqid=af5b1b160001979a000000065b5f014c" target="_blank" rel="noopener">拓扑结构</a>。</p><h1 id="拓扑结构的形成"><a href="#拓扑结构的形成" class="headerlink" title="拓扑结构的形成"></a>拓扑结构的形成</h1><p><img src="https://img-blog.csdn.net/2018073020163062?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><ul><li>两台交换机</li><li>机器1只知道机器4的IP地址，还需要机器4的MAC地址才能把包送到机器4</li><li>机器1发起广播，没机器2的事</li><li>交换机A收到，转发给出了来源处的其他网口</li><li>机器3收到，也没机器3的事</li><li>交换机B连着局域网LAN2，所以交换机B也收到，也继续广播</li><li>机器4和机器5收到，机器4响应MAC地址</li><li>ARP请求成功</li></ul><p><strong>机器的链路层能够学习，交换机也能够学习</strong></p><ul><li>机器A当经过一次交换机A，那么交换机A以后都知道机器A是在左边局域网LAN1</li></ul><p>机器多了，多台交换机就有可能连接着相同的两个LAN，就回形成环路</p><h1 id="解决常见的环路问题"><a href="#解决常见的环路问题" class="headerlink" title="解决常见的环路问题"></a>解决常见的环路问题</h1><p><img src="https://img-blog.csdn.net/20180730201823879?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""> </p><ul><li>机器1需要访问机器2</li><li>交换机A此时还没有学习，并不知道A是在LAN1还是LAN2于是，广播到LAN2</li><li>LAN2存在着这个广播包，于是交换机B从右边接受到LAN2过来的广播包，广播到LAN1</li><li>交换机A此时还是不知道机器2在哪，于是再次广播到LAN2</li><li>不断重复3、4步骤</li></ul><p>一开始交换机A和B都接受到左边LAN1中机器1的广播包，学习到机器1是在左边的LAN1中。</p><p>但当交换机AB把该广播包广播到右边LAN2时，A接受到来自B的广播包，B也接受到来自A的广播包，不断循环。</p><p>其他机器也继续发着广播包，通信链路越来越堵，最后走不动。</p><p>于是就产生了死循环的环路问题。</p><p>于是应用了STP协议</p><h1 id="理解STP协议"><a href="#理解STP协议" class="headerlink" title="理解STP协议"></a>理解STP协议</h1><p>在数据结构中，有一个方法叫作<strong>最小生成树</strong>。有环的我们常称为图。将图中的环破了，就生成了树。在计算机网络中，生成树的算法叫作<strong>STP</strong>，全称<strong>Spanning Tree Protocol</strong>。</p><p>应用了STP协议的办公室交换机结构图<br> <img src="https://img-blog.csdn.net/20180730202013862?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br><strong>概念</strong>：</p><ul><li>Root Bridge-根交换机</li><li>Designate Bridges-子交换机</li><li>Bridge Protocol Data Units（BPDU）-网桥协议数据单位元</li><li>Priority Vector – 优先级向量</li></ul><h2 id="BPDU介绍"><a href="#BPDU介绍" class="headerlink" title="BPDU介绍"></a>BPDU介绍</h2><ol><li>BPDU是交换机之间发送的用于构建无环路拓扑的消息称为网桥协议数据单元</li><li>BPDU是二层报文</li><li>BPDU中包括用于计算生成树的参数信息 </li></ol><p><img src="https://img-blog.csdn.net/20180730202236111?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><ul><li>Root Bridge ID （BID）—本交换机认为的根交换机ID</li><li>Root Path Cost —本交换机认为的根交换机路径开销</li><li>Bridge ID —本交换机的ID</li><li>Port ID—发送该BPDU的端口ID</li></ul><p><strong>也就是说BPDU代表两交换机连接的连接与开销</strong></p><h1 id="STR协议过程"><a href="#STR协议过程" class="headerlink" title="STR协议过程"></a>STR协议过程</h1><p> <img src="https://img-blog.csdn.net/20180730202420949?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br><strong>哪个数字最小就是根交换机</strong><br><strong>其他交换机哪条通往根交换机最短的路就是交换机转发广播包的路径</strong><br>最终转发路径如下<br> <img src="https://img-blog.csdn.net/20180730202505239?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>原本1-5-6是一个环，确定好最短通信路径，这个环通信就不成环了</p><ul><li>5要是需要转发到1就，5-&gt;6-&gt;1</li><li>1要是需要转发到5就，1-&gt;6&gt;5</li></ul><h1 id="解决广播问题和安全问题"><a href="#解决广播问题和安全问题" class="headerlink" title="解决广播问题和安全问题"></a>解决广播问题和安全问题</h1><p><strong>机器多了，交换机多了，就需要划分广播域来更方便管理了</strong><br>两种划分方法<br>物理隔离：<br>配置单的独交换机，单独的子网，通过路由器（另讲）向其他广播域沟通<br>虚拟隔离：<br>VLAN，虚拟局域网。<br><img src="https://img-blog.csdn.net/20180730202801310?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p><img src="https://img-blog.csdn.net/2018073020281655?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>如果交换机是支持VLAN的，可以设置交换机每个端口所属的VLAN，交换机会把广播包的二层头取下来，识别VLAN ID，广播包的转发只在相同的端口 VLAN ID中进行。</p><p>端口会根据所属VLAN ID在广播包二层头中加一个TAG再转发出去。</p><p>Tag里面有一个端口 VLAN ID，一共 12 位，可以划分4096个VLAN。用以确定那个相同VLAN ID端口接受。</p><p>具体可以参考以下链接内容：<br><a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/419962?fromtitle=VLAN&amp;fromid=320429&amp;fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/419962?fromtitle=VLAN&amp;fromid=320429&amp;fr=aladdin</a><br><a href="http://network.51cto.com/art/201409/450885.htm" target="_blank" rel="noopener">http://network.51cto.com/art/201409/450885.htm</a></p><p>交换机之间通过叫做Trunk口来进行连接，用来转发属于任何VLAN的口。<br>这里介绍的是一般复杂的的场景，还有云计算其他的另说。</p><h1 id="知识复盘"><a href="#知识复盘" class="headerlink" title="知识复盘"></a>知识复盘</h1><h2 id="如何解决交换机环路问题？"><a href="#如何解决交换机环路问题？" class="headerlink" title="如何解决交换机环路问题？"></a>如何解决交换机环路问题？</h2><p>应用STP协议</p><h2 id="如何划分广播域？"><a href="#如何划分广播域？" class="headerlink" title="如何划分广播域？"></a>如何划分广播域？</h2><p>物理隔离或者虚拟隔离VLAN，一般使用虚拟隔离</p><h1 id="额外知识"><a href="#额外知识" class="headerlink" title="额外知识"></a>额外知识</h1><h2 id="STP协议有什么缺点？"><a href="#STP协议有什么缺点？" class="headerlink" title="STP协议有什么缺点？"></a>STP协议有什么缺点？</h2><ol><li><strong>拓扑收敛慢</strong>，当网络拓扑发生改变的时候，生成树协议需要50-52秒的时间才能完成拓扑收敛，数越大需要的时间越长，这期间就是网络中断。</li><li><strong>不能提供负载均衡的功能</strong>。当网络中出现环路的时候，生成树协议简单的将环路进行Block，这样该链路就不能进行数据包的转发，浪费网络资源。</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>当交换机的数目越来越多的时候，会遭遇<strong>环路问题</strong>，让网络包迷路造成<a href="https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD%E9%A3%8E%E6%9A%B4/3574878?fr=aladdin" target="_blank" rel="noopener">广播风暴</a>，这就需要使用 STP 协议，将有环路的图变成没有环路的树，从而解决环路问题。</li><li>交换机数目多会面临隔离问题，可以通过 VLAN 形成虚拟局域网，从而解决广播问题和安全问题。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暂时还没有完全理解，笔记逻辑存在一些BUG&lt;/p&gt;
    
    </summary>
    
      <category term="网络协议" scheme="http://itfriends.xyz/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议" scheme="http://itfriends.xyz/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>【架构】笔记一 |  初识框架与架构</title>
    <link href="http://itfriends.xyz/2018/07/29/%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%88%9D%E8%AF%86%E6%A1%86%E6%9E%B6%E4%B8%8E%E6%9E%B6%E6%9E%84/"/>
    <id>http://itfriends.xyz/2018/07/29/【架构】笔记一-初识框架与架构/</id>
    <published>2018-07-28T17:44:05.000Z</published>
    <updated>2018-07-29T02:53:33.521Z</updated>
    
    <content type="html"><![CDATA[<p>有些难啃</p><a id="more"></a><h1 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h1><ul><li><strong>组件是达到可复用要求的模块</strong></li><li><strong>架构是设计图纸，框架是工程师</strong></li></ul><h1 id="系统与子系统"><a href="#系统与子系统" class="headerlink" title="系统与子系统"></a>系统与子系统</h1><p>“<strong>系统</strong>”的维基百科定义：<br><strong><code>系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体。它的意思是“总体”“整体”或“联盟”。</code></strong><br>”<strong>子系统</strong>“的维基百科定义：<br><strong><code>子系统也是由一群有关联的个体所组成的系统，多半会是更大系统中的一部分。</code></strong></p><p>子系统的定义和系统定义是一样的，只是观察的角度有差异，一个系统可能是另外一个更大系统的子系统。<br>例如</p><ul><li>微信本身是一个系统，包含聊天、登录、支付、朋友圈等子系统</li><li>朋友圈这个系统又包括动态、评论、点赞等子系统</li></ul><p>无论是系统还是子系统相对于自身系统而言，整个系统都是由个体也就是<strong>模块</strong>或<strong>组件</strong>构成的。</p><h1 id="模块与组件"><a href="#模块与组件" class="headerlink" title="模块与组件"></a>模块与组件</h1><ul><li>都是基于功能划分的单位</li><li>模块是从业务维度上职责的划分</li><li>组件是技术维度上的复用</li></ul><p>从设计上来看，组件强调复用，模块强调职责(内聚、分离)，或者说<strong>组件是达到可复用要求的模块</strong>。</p><p>模块和组件都是系统的组成部分，只是从不同的角度拆分系统。</p><h1 id="框架与架构"><a href="#框架与架构" class="headerlink" title="框架与架构"></a>框架与架构</h1><ul><li>框架关注的是“规范”，是面向编程或配置的半成品</li><li>架构关注的是“结构”，是软件系统的金字塔结构</li></ul><p><strong>所谓结构，是指任何一件事情都可以看做一个系统。</strong><br>而任何一个系统，都有多个元素（<strong>个体</strong>）组成，这些系统组成的元素之间的关系形成结构</p><p><strong>而规范就是要求按照这个结构进行操作的一个标准</strong></p><p><strong>架构是设计图纸，目的是“做什么”；框架是工程师，目的是“做出来”。</strong></p><p>选择不同的框架就是选择不同的工程师。</p><p>哪怕是基于同一张设计图纸不同的工程师（不同的框架）做出来的效果各不一样（性能的差异）。</p><p>比如说Spring MVC框架这个工程师，他拿着MVC架构这张设计图开发出来web应用了。</p><ul><li>这个web应用是MVC架构设计的，是基于Spring MVC框架开发的<br>（这个web工程是按照MVC设计图纸开发的，是Spring MVC工程师做的）</li><li>Spring MVC框架基于MVC架构设计开发了这个web应用<br>（Spring MVC工程师按照MVC这设计图纸做出了这个web工程）</li></ul><p>当我们想造一房子时，我们可以自己学习成为工程师（造轮子）来建造，但也许更好的选择是聘请专业的工程师（现成框架），我们提供材料（编写模块或组件）让其快速实现目标。</p><h1 id="知识复盘"><a href="#知识复盘" class="headerlink" title="知识复盘"></a>知识复盘</h1><h2 id="当我们在谈架构的时候，其实是在谈什么？"><a href="#当我们在谈架构的时候，其实是在谈什么？" class="headerlink" title="当我们在谈架构的时候，其实是在谈什么？"></a>当我们在谈架构的时候，其实是在谈什么？</h2><p>设计思想</p><h2 id="当我们在谈框架的时候，其实是在谈什么？"><a href="#当我们在谈框架的时候，其实是在谈什么？" class="headerlink" title="当我们在谈框架的时候，其实是在谈什么？"></a>当我们在谈框架的时候，其实是在谈什么？</h2><p>设计思想的具体化（用Spring、JSF、GWT哪个实现）</p><h2 id="如何正确介绍一个系统的架构与框架？"><a href="#如何正确介绍一个系统的架构与框架？" class="headerlink" title="如何正确介绍一个系统的架构与框架？"></a>如何正确介绍一个系统的架构与框架？</h2><p>这个XXX系统是基于XXX <strong>架构设计</strong>，基于XXX <strong>框架开发</strong>的</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>系统是基于架构设计，基于框架开发，由模块或组件构造。</li><li>凡是可以体现出设计思想的都可以看做是架构，凡是可以根据设计开发出产品的都可以看做框架。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些难啃&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://itfriends.xyz/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://itfriends.xyz/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【网络协议】笔记五 | 从物理层到MAC层：如何在宿舍里自己组网玩联机游戏？</title>
    <link href="http://itfriends.xyz/2018/07/28/%E3%80%90%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%91%E7%AC%94%E8%AE%B0%E4%BA%94-%E4%BB%8E%E7%89%A9%E7%90%86%E5%B1%82%E5%88%B0MAC%E5%B1%82%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%BF%E8%88%8D%E9%87%8C%E8%87%AA%E5%B7%B1%E7%BB%84%E7%BD%91%E7%8E%A9%E8%81%94%E6%9C%BA%E6%B8%B8%E6%88%8F%EF%BC%9F/"/>
    <id>http://itfriends.xyz/2018/07/28/【网络协议】笔记五-从物理层到MAC层：如何在宿舍里自己组网玩联机游戏？/</id>
    <published>2018-07-28T07:31:24.000Z</published>
    <updated>2018-07-28T07:38:29.366Z</updated>
    
    <content type="html"><![CDATA[<p>网线+交换机<br><a id="more"></a></p><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>物理层与链路层</li><li>链路层与MAC层</li><li>HUB与交换机</li></ul><h1 id="第一层（物理层）"><a href="#第一层（物理层）" class="headerlink" title="第一层（物理层）"></a>第一层（物理层）</h1><p>两台电脑插网线互通，通信的前提两台电脑配好<strong>IP地址</strong>、<strong>子网掩码</strong>和<strong>默认网关</strong>。这样两台机器构成了局域网（<strong>LAN</strong>）</p><p>但有第三台机器协议连接的时候就需要<strong>HUB</strong>（现在基本被淘汰，使用交换机，另说）。</p><p>这种设备有多个口，可以将宿舍里的多台电脑连接起来。但是，和交换机不同，集线器没有大脑，它完全在物理层工作。它会将自己收到的每一个字节，都复制到其他端口上去。这是第一层物理层联通的方案。</p><h1 id="第二层（数据链路层）"><a href="#第二层（数据链路层）" class="headerlink" title="第二层（数据链路层）"></a>第二层（数据链路层）</h1><ul><li>数据链路层分为上层LLC（<strong>逻辑链路控制</strong>），和下层的MAC（<strong>介质访问控制</strong>）</li><li>MAC主要负责控制与连接物理层的物理介质。在发送数据的时候</li><li>MAC协议可以事先判断是否可以发送数据，如果可以发送将给数据加上一些控制信息，最终将数据以及控制信息以规定的格式发送到物理层</li><li>在接收数据的时候，MAC协议首先判断输入的信息并是否发生传输错误，如果没有错误，则去掉控制信息发送至LLC（逻辑链路控制）层</li></ul><p>HUB采取的是广播的模式，广播数据包，但要解决几个问题：</p><ul><li>这个包是发给谁的？谁应该接收？</li><li>大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？</li><li>如果发送的时候出现了错误，怎么办？</li></ul><h2 id="这个包是发给谁的？谁应该接收？"><a href="#这个包是发给谁的？谁应该接收？" class="headerlink" title="这个包是发给谁的？谁应该接收？"></a>这个包是发给谁的？谁应该接收？</h2><ul><li>这里用到一个物理地址，叫做<strong>链路层地址</strong>但是因为第二层主要解决<strong>媒体接入控制</strong>的问题，所以它常被称为<strong>MAC地址</strong></li><li>靠数据包中目标MAC地址，然后就是双子楼的模式（笔记二）</li><li>如果不知道MAC地址，就需要使用<strong>ARP协议</strong>在广播中“吼”，因为是在局域网中，所以能得到目标IP的回复</li><li>为了避免每次都用 ARP 请求，机器本地也会进行 <strong>ARP 缓存</strong></li><li>IP 随时会改变，所以 ARP 的 MAC 地址缓存过一段时间就会过期<br><img src="https://img-blog.csdn.net/20180728152623923?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>广播包中，具体的询问和回答的报文如下：<br><img src="https://img-blog.csdn.net/20180728152925653?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？</li></ul><hr><p>MAC的全称是<strong>Medium Access Control</strong>，即<strong>媒体访问控制</strong>，制定多路访问规则来控制访问，防止发生混乱。这里可不关MAC地址的事噢</p><h2 id="如果发送的时候出现了错误，怎么办？"><a href="#如果发送的时候出现了错误，怎么办？" class="headerlink" title="如果发送的时候出现了错误，怎么办？"></a>如果发送的时候出现了错误，怎么办？</h2><p>使用<strong>CRC</strong>，也就是<strong>循环冗余检测</strong>。通过 <strong>XOR 异或的算法</strong>，来计算整个包是否在发送的过程中出现了错误</p><h1 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h1><p>在局域网中，用HUB连接起来，一旦机器数目多了产生冲突的概率就提高了，如果这个区域里有冲突，所有电脑都受影响。而且把不需要的包转发过去纯属浪费。</p><p>于是就是需要使用交换机，交换机胡交换机会学习来知道每个口电脑的MAC地址：<strong>一开始把包转发给除了来的那个口之外的其他所有的的口，而接受到包的口如果不是目标就会把包的来源口记住，只要以后有包的目标地址是这个来口，直接发送这个口就行了。</strong></p><p>然后这样重复一段时间，就有了整个网络的结构，这时基本不用广播，全部可以准确转发了</p><p>每个机器IP地址改变时，所在的口业会改变，因而交换机上的学习结果，称为<strong>转发表</strong>，是有一个过期时间。</p><h1 id="知识复盘"><a href="#知识复盘" class="headerlink" title="知识复盘"></a>知识复盘</h1><h2 id="第一层物理层是干什么的？"><a href="#第一层物理层是干什么的？" class="headerlink" title="第一层物理层是干什么的？"></a>第一层物理层是干什么的？</h2><p>机器之间达成连接</p><h2 id="第二层链路层是干什么的？"><a href="#第二层链路层是干什么的？" class="headerlink" title="第二层链路层是干什么的？"></a>第二层链路层是干什么的？</h2><p>管理包的接收</p><h2 id="在局域网中知道目标IP地址如何寻找目标MAC？"><a href="#在局域网中知道目标IP地址如何寻找目标MAC？" class="headerlink" title="在局域网中知道目标IP地址如何寻找目标MAC？"></a>在局域网中知道目标IP地址如何寻找目标MAC？</h2><p>ARP请求</p><h1 id="额外知识"><a href="#额外知识" class="headerlink" title="额外知识"></a>额外知识</h1><h2 id="交换机和HUB有什么区别？"><a href="#交换机和HUB有什么区别？" class="headerlink" title="交换机和HUB有什么区别？"></a>交换机和HUB有什么区别？</h2><ul><li><strong>交换机可以分割冲突域而 HUB不可以分割冲突域 ，这是他们最本质的区别</strong><br>hub连N台电脑，他们共享在一个区域里，如果这个区域里有冲突，所有电脑都受影响。<br>交换机连n台电脑，每个交换机端口是一个独立的区域，即使有冲突，冲突也局限在相对应的交换机端口，不影响其他电脑</li><li><strong>HUB是广播数据包，交换机是隔离数据包</strong></li></ul><p>链接：<a href="https://zhidao.baidu.com/question/175872130001476004.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/175872130001476004.html</a></p><h2 id="路由器与交换机有什么区别？"><a href="#路由器与交换机有什么区别？" class="headerlink" title="路由器与交换机有什么区别？"></a>路由器与交换机有什么区别？</h2><ul><li>工作层次不同：交换机比路由器更简单，路由器比交换器能获取更多信息</li><li>数据转发所依据的对象不同</li><li>传统的交换机只能分割冲突域，不能分割广播域;而路由器可以分割广播域</li><li>路由器提供了防火墙的服务</li></ul><p>链接：<a href="http://network.51cto.com/art/201505/477755.htm" target="_blank" rel="noopener">http://network.51cto.com/art/201505/477755.htm</a></p><h2 id="如果一个局域网里面有多个交换机，ARP-广播的模式会出现什么问题呢？"><a href="#如果一个局域网里面有多个交换机，ARP-广播的模式会出现什么问题呢？" class="headerlink" title="如果一个局域网里面有多个交换机，ARP 广播的模式会出现什么问题呢？"></a>如果一个局域网里面有多个交换机，ARP 广播的模式会出现什么问题呢？</h2><p><strong>ARP广播时，交换机会将一个端口收到的包转发到其它所有的端口上。</strong></p><p>比如数据包经过交换机A到达交换机B，交换机B又将包复制为多份广播出去。 </p><p>如果整个局域网存在一个环路，使得数据包又重新回到了最开始的交换机A，这个包又会被A再次复制多份广播出去。 </p><p>如此循环，数据包会不停得转发，而且越来越多，最终占满带宽，或者使解析协议的硬件过载，行成广播风暴。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>物理层是连接，链路层是管理</li><li>MAC层是链路层的子层</li><li>MAC层是用来解决多路访问的堵车问题</li><li>ARP是通过“吼”的方式来寻找目标MAC地址</li><li>交换机是有MAC地址学习能力的，学完了它就知道谁在哪，不用广播</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网线+交换机&lt;br&gt;
    
    </summary>
    
      <category term="网络协议" scheme="http://itfriends.xyz/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议" scheme="http://itfriends.xyz/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>【网络协议】笔记四 | DHCP与PXE：IP是怎么来的，又是怎么没的？</title>
    <link href="http://itfriends.xyz/2018/07/27/%E3%80%90%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%91%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%9ADHCP%E4%B8%8EPXE%EF%BC%9AIP%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84%EF%BC%8C%E5%8F%88%E6%98%AF%E6%80%8E%E4%B9%88%E6%B2%A1%E7%9A%84%EF%BC%9F/"/>
    <id>http://itfriends.xyz/2018/07/27/【网络协议】笔记四：DHCP与PXE：IP是怎么来的，又是怎么没的？/</id>
    <published>2018-07-27T14:56:24.000Z</published>
    <updated>2018-07-27T14:58:06.117Z</updated>
    
    <content type="html"><![CDATA[<p>租来的<br><a id="more"></a></p><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>配置IP地址</li><li>房产中介DHCP</li><li>装修队PXE</li></ul><p>如果需要和其他机器通讯，我们就需要一个通讯地址，我们需要给网卡配置这么一个地址。</p><h1 id="如何配置-IP-地址？"><a href="#如何配置-IP-地址？" class="headerlink" title="如何配置 IP 地址？"></a>如何配置 IP 地址？</h1><p>使用 net-tools：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ifconfig eth1 <span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span>/<span class="number">24</span> </span><br><span class="line">$ sudo ifconfig eth1 up</span><br></pre></td></tr></table></figure><p>使用 iproute2：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo<span class="built_in"> ip </span>addr <span class="builtin-name">add</span> 10.0.0.1/24 dev eth1 </span><br><span class="line">$ sudo<span class="built_in"> ip </span>link <span class="builtin-name">set</span> up eth1</span><br></pre></td></tr></table></figure><p>之前说过，有了目标ip地址，还需要目标MAC地址，而最终的目标MAC地址需要经过一个个网关才可以寻得，而当前需要寻得的是当前局域网中的网关的MAC地址。<br>Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。<br>Linux会判断这个目标ip地址和自己的其中一个网卡是否同一个网段，才会发送ARP请求，获取网关的MAC地址，然后将包发出去。<br>如果没有配置网关，包就发包出去。<br>所以配置ip地址之前需要知道系统中网卡的网段，或者向管理员申请分配一段正确的ip地址。<br>正配置的时候，一定不是直接用命令配置的，而是放在一个配置文件里面。<br>不同系统的配置文件格式不同，但是无非就是 <strong>CIDR</strong>、<strong>子网掩码</strong>、<strong>广播地址</strong>和<strong>网关地址</strong>。</p><h1 id="动态主机配置协议（DHCP）"><a href="#动态主机配置协议（DHCP）" class="headerlink" title="动态主机配置协议（DHCP）"></a>动态主机配置协议（DHCP）</h1><p>除了手动配置，还有一种是自动分配配置。<br>自动配置的协议，也就是称动态主机配置协议（Dynamic Host Configuration Protocol），简称DHCP。<br>网络管理员只需要备注一段共享ip地址，每一台新接入的机器都通过DHCP吸引，来这个共享的IP地址里申请，然后自动配置好就可以了，下线自动归还。<br>如果是数据中心里面的服务器，IP 一旦配置好，基本不会变，这就相当于买房自己装修。DHCP 的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了。<br>通信都是广播包的形式：<br> <img src="https://img-blog.csdn.net/20180727223550105?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><ol><li>租客叫一声：我是XXX（MAC地址）要租房（IP地址）<br><img src="https://img-blog.csdn.net/20180727224012462?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></li><li>许多房产中介立马带着资料（提供的IP地址）赶过来回应<br><img src="https://img-blog.csdn.net/20180727224031166?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></li><li>租客选择一位回复最快最热情的房产中介，并告诉其他房产中介自己已经选择了那位房产中介，多谢其他房产中介并让他们拿回各自的资料给下一位租客<br><img src="https://img-blog.csdn.net/20180727224057177?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></li><li>房产中介拿签订合同过来给租客确认进住<br><img src="https://img-blog.csdn.net/20180727224113472?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></li><li>租客在租期过去一本的时候，需要告诉房产中介自己是否续期，然后房产中介回复更新确认租房信息，租客根据回复安排之后的一切。</li></ol><p>网络管理员不仅能自动分配 IP 地址，还能帮你自动安装操作系.系统</p><h1 id="预启动执行环境（PXE）"><a href="#预启动执行环境（PXE）" class="headerlink" title="预启动执行环境（PXE）"></a>预启动执行环境（PXE）</h1><p>例如数据中心要给几百台机器自动安装操作系统就需要PXE了。</p><h2 id="PXE是什么？"><a href="#PXE是什么？" class="headerlink" title="PXE是什么？"></a>PXE是什么？</h2><pre><code>PXE(preboot execute environment，预启动执行环境)是由Intel公司开发的最新技术，工作于Client/Server的网络模式，支持工作站通过网络从远端服务器下载映像，并由此支持通过网络启动操作系统，在启动过程中，终端要求服务器分配IP地址，再用TFTP（trivial file transfer protocol）或MTFTP(multicast trivial file transfer protocol)协议下载一个启动软件包到本机内存中执行，由这个启动软件包完成终端（客户端）基本软件设置，从而引导预先安装在服务器中的终端操作系统。PXE可以引导多种操作系统，如：Windows95/98/2000/windows2003/windows2008/winXP/win7/win8,linux系列系统等。</code></pre><h2 id="PXE表现形式："><a href="#PXE表现形式：" class="headerlink" title="PXE表现形式："></a>PXE表现形式：</h2><p>PXE最直接的表现是，在网络环境下工作站可以省去硬盘，但又不是通常所说的无盘站的概念，因为使用该技术的PC在网络方式下的运行速度要比有盘PC快3倍以上。当然使用PXE的PC也不是传统意义上的TERMINAL终端，因为使用了PXE的PC并不消耗服务器的CPU，RAM等资源，故服务器的硬件要求极低。</p><h2 id="PXE启动原理"><a href="#PXE启动原理" class="headerlink" title="PXE启动原理"></a>PXE启动原理</h2><p>PXE 协议分为客户端和服务器端，由于还没有操作系统，只能先把客户端放在 BIOS 里面。当计算机引导时，BIOS把 PXE Client 调入内存中执行，然后由 PXE Client 将放置在远端的文件通过网络下载到本地运行<br>解析 PXE 的工作过程<br> <img src="https://img-blog.csdn.net/20180727223937827?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>这里有些像装修队：<strong>新房啥也没有装修，然后找装修公司（DHCP Server）安排一只装修队（TFTP Server）学习，想弄啥就跟装修队说。</strong></p><h1 id="知识复盘"><a href="#知识复盘" class="headerlink" title="知识复盘"></a>知识复盘</h1><h2 id="在跨网段调用中，是如何获取目标IP的mac地址的？"><a href="#在跨网段调用中，是如何获取目标IP的mac地址的？" class="headerlink" title="在跨网段调用中，是如何获取目标IP的mac地址的？"></a>在跨网段调用中，是如何获取目标IP的mac地址的？</h2><p>从源IP网关获取所在网关mac, 然后又替换为目标IP所在网段网关的mac, 最后是目标IP的mac地址  </p><h2 id="手动配置麻烦，怎么办？"><a href="#手动配置麻烦，怎么办？" class="headerlink" title="手动配置麻烦，怎么办？"></a>手动配置麻烦，怎么办？</h2><p><strong>DHCP</strong>！Dynamic Host Configuration Protocol！<br>DHCP, 让你自动配置IP，如同租客与房产中介商谈、签约、续租，广播还不能“抢单”。  </p><h2 id="如果新来的，房子是空的-没有操作系统-，怎么办？"><a href="#如果新来的，房子是空的-没有操作系统-，怎么办？" class="headerlink" title="如果新来的，房子是空的(没有操作系统)，怎么办？"></a>如果新来的，房子是空的(没有操作系统)，怎么办？</h2><p><strong>PXE</strong>， Pre-boot Execution Environment.<br>“装修队”PXE，帮你安装操作系统。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>DHCP 协议主要是用来给客户租用 IP 地址，和房产中介很像，要商谈、签约、续租，广播还不能“抢单”</li><li>DHCP 协议能给客户推荐“装修队”PXE，能够安装操作系统</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;租来的&lt;br&gt;
    
    </summary>
    
      <category term="网络协议" scheme="http://itfriends.xyz/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议" scheme="http://itfriends.xyz/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>【网络协议】笔记三 | ifconfig：最熟悉又陌生的命令行</title>
    <link href="http://itfriends.xyz/2018/07/26/%E3%80%90%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%91%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9Aifconfig%EF%BC%9A%E6%9C%80%E7%86%9F%E6%82%89%E5%8F%88%E9%99%8C%E7%94%9F%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>http://itfriends.xyz/2018/07/26/【网络协议】笔记三：ifconfig：最熟悉又陌生的命令行/</id>
    <published>2018-07-26T14:56:44.000Z</published>
    <updated>2018-07-26T16:04:47.312Z</updated>
    
    <content type="html"><![CDATA[<p>恩，熟悉的陌生人</p><a id="more"></a><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>查看IP地址</li><li>IP地址五大类</li><li>CIDR</li><li>私有与公有地址</li></ul><h1 id="怎么查看IP地址？"><a href="#怎么查看IP地址？" class="headerlink" title="怎么查看IP地址？"></a>怎么查看IP地址？</h1><p>通常Windows是<strong>ipconfig</strong>，linux是<strong>ifconfig</strong>，而linux还可以使用<strong>ip addr</strong>查看</p><p>例如运行ip addr</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@test:~#<span class="built_in"> ip </span>addr</span><br><span class="line">1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN<span class="built_in"> group default </span></span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP<span class="built_in"> group default </span>qlen 1000</span><br><span class="line">    link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.100.122.2/24 brd 10.100.122.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::f816:3eff:fec7:7975/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p><strong>IP 地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码。</strong><br>既然是门牌号码，就不能一样起冲突，好比大家都是六单元1001号，那快递就找不到地方了。<br>如上输出的结果，10.100.122.2 就是一个 IP 地址。这个地址被点分隔为四个部分，每个部分 8 个 bit，所以 IP 地址总共是 32 位。但其实根本不够用，于是就有了<strong>IPv6</strong>地址，也就是上面输出结果里面 inet6 fe80::f816:3eff:fec7:7975/64，这个有 128 ，而位前面说32位的是<strong>IPv4</strong>。<br>本来IPv4地址就不够，还被分成5大类</p><h1 id="IP地址5大类"><a href="#IP地址5大类" class="headerlink" title="IP地址5大类"></a>IP地址5大类</h1><p> <img src="https://img-blog.csdn.net/20180726204612635?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p><strong>网络号</strong> ：用于识别主机所在的网络；  <strong>主机号</strong> ：用于识别该网络中的主机。</p><ul><li><strong>A类</strong>，保留给政府机构</li><li><strong>B类</strong>，分配给中等规模的公司</li><li><strong>C类</strong>，分配给任何需要的人</li><li><strong>D类</strong>，用于组播</li><li><strong>E类</strong>，用于实验，各类可容纳的地址数目不同</li></ul><p>在网络地址中，至少在当时设计的时候，对于 A、B、 C 类主要分两部分，前面一部分是网络号，后面一部分是主机号。这很好理解，大家都是六单元 1001 号，我是小区 A 的六单元 1001 号，而你是小区 B 的六单元 1001 号。</p><p>下面这个表格，详细地展示了 A、B、C 三类地址所能包含的主机的数量<br> <img src="https://img-blog.csdn.net/20180726205234953?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>这里拿C类地址说明，C类地址主机号是8位，也就2的8次方应该是256个主机，但能连却只有254，这是因为还有一个是广播地址，一个是路由地址，所以少了2个！比如192.168.0.255用于192.168.0.段的广播了，而192.168.0.0分配成你的路由器地址了，所以机子少了2个。<br>但C类的主机太少，而D类的太多，于是就有了现在折中的CIDR</p><h1 id="无类型域间选路（CIDR）"><a href="#无类型域间选路（CIDR）" class="headerlink" title="无类型域间选路（CIDR）"></a>无类型域间选路（CIDR）</h1><p><strong>特点</strong></p><ul><li>CIDR主要是为了更有效分配和管理IPv4地址，CIDR使IP地址又回到无分类的两级编码。记法：IP地址：：={&lt;&lt;网络前缀&gt;，&lt;&lt;主机号&gt;}。CIDR还使用“斜线记法”即在IP地址后面加上“/”然后写网络前缀所占的位数。</li><li>CIDR把网络前缀都相同的连续IP地址组成一个“CIDR地址块”，即强化路由聚合（构成超网）。</li></ul><p>伴随着 CIDR 存在的，一个是<strong>广播地址</strong>，10.100.122.255。如果发送这个地址，所有10.100.122 网络里面的机器都可以收到。<br>另一个是<strong>子网掩码</strong> 255.255.255.0。</p><p>Ａ类的默认子网掩码　255.0.0.0　<br>Ｂ类的默认子网掩码　255.255.0.0　<br>Ｃ类的默认子网掩码　255.255.255.0　</p><p><strong>IP地址和子网掩码都转换为二进制做逻辑与运算的结果为本网段的网络号，是区分不同网段的方法</strong>。</p><p>例：<br>192.168.1.1（11000000.10101000.00000001.00000001）<br> 255.255.255.0（11111111.11111111.11111111.00000000）<br>两个做与运算：<br>       11000000.10101000.00000001.00000000（192.168.1.0）<br>即192.168.1.0为本网段的网络号</p><p>更多CIDR的详解可以阅读以下文章：<br><a href="http://www.cnblogs.com/wxgblogs/p/5628092.html" target="_blank" rel="noopener">http://www.cnblogs.com/wxgblogs/p/5628092.html</a><br><a href="http://blog.sina.com.cn/s/blog_5edae1a101018hgo.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_5edae1a101018hgo.html</a></p><h1 id="公有-IP-地址和私有-IP-地址"><a href="#公有-IP-地址和私有-IP-地址" class="headerlink" title="公有 IP 地址和私有 IP 地址"></a>公有 IP 地址和私有 IP 地址</h1><p>IP地址由IANA（Internet地址分配机构）管理和分配，任何一个IP地址要能够在Internet上使用就必须由IANA分配，IANA 分配的能够在Internet上正常使用的IP地址称之为公共IP地址；IANA保留了一部份IP地址没有分配给任何机构和个人，这部份IP地址不能在 Internet上使用，此类IP地址就称之为私有IP地址。为什么私有IP地址不能在Internet上使用呢？因为Internet上没有私有IP地 址的路由。<br><img src="https://img-blog.csdn.net/20180726205743806?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>我们继续看上面的表格。表格最右列是私有 IP 地址段。平时我们看到的数据中心里，办公室、家里或学校的 IP 地址，一般都是私有 IP 地址段。因为这些地址允许组织内部的 IT 人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有 IP 地址段和我学校的可以是一样的。<br>这就像每个小区有自己的楼编号和门牌号，你们小区可以叫 6 栋，我们小区也叫 6 栋，没有任何问题。但是一旦出了小区，就需要使用公有 IP 地址。就像人民路 888 号，是国家统一分配的，不能两个小区都叫人民路 888 号。</p><h1 id="如何得出网络号、掩码、广播地址？"><a href="#如何得出网络号、掩码、广播地址？" class="headerlink" title="如何得出网络号、掩码、广播地址？"></a>如何得出网络号、掩码、广播地址？</h1><p>例如CIDR  10.100.122.2/24，后面 24 的意思是，32 位中，前 24 位是网络号，后 8 位是主机号；32位子网掩码前24位是1，后8位是0。</p><ul><li>由子网掩码和IP地址的进行二进制“与”运算，算出网络地址；</li><li>网络地址二进制后连续的0栋变成1就是广播地址；</li><li>网络地址+1就是第一个主机二进制地址，广播低价-1即为最后一个主机地址</li><li><strong>可用主机的数量=2^二进制位数的主机-2</strong></li><li>减2是因为主机不包括网络地址和广播地址。</li></ul><p>参考：<br><a href="https://blog.csdn.net/gatieme/article/details/50989257" target="_blank" rel="noopener">https://blog.csdn.net/gatieme/article/details/50989257</a><br><a href="http://uule.iteye.com/blog/2102484" target="_blank" rel="noopener">http://uule.iteye.com/blog/2102484</a><br><a href="https://zhidao.baidu.com/question/1116507203928197699.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1116507203928197699.html</a></p><h1 id="继续了解ip-addr"><a href="#继续了解ip-addr" class="headerlink" title="继续了解ip addr"></a>继续了解ip addr</h1><p>在 IP 地址的后面有个 <strong>scope</strong>，对于 eth0 这张网卡来讲，是 <strong>global</strong>，说明这张网卡是可以对外的，可以接收来自各个地方的包。对于 <strong>lo</strong> 来讲，是 <strong>host</strong>，说明这张网卡仅仅可以供本机相互通信。<br>lo 全称是loopback，又称<strong>环回接口</strong>，往往会被分配到 127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。</p><h1 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h1><p>在 IP 地址的上一行是 link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff，这个被称为MAC地址，是一个网卡的物理地址，用十六进制，6 个 byte 表示。</p><h1 id="网络设备的状态标识"><a href="#网络设备的状态标识" class="headerlink" title="网络设备的状态标识"></a>网络设备的状态标识</h1><p>解析完了 MAC 地址，我们再来看 <strong>BROADCAST,MULTICAST,UP,LOWER_UP&gt;</strong> 是干什么的？这个叫作net_device flags，网络设备的<strong>状态标识</strong>。  </p><ul><li>UP 表示网卡处于启动的状态</li><li>BROADCAST 表示这个网卡有广播地址，可以发送广播包</li><li>MULTICAST 表示网卡可以发送多播包</li><li>LOWER_UP 表示 L1 是启动的，也即网线插着呢</li></ul><p><strong>MTU1500 是指什么意思呢？是哪一层的概念呢？</strong></p><ul><li>最大传输单元 MTU 为 1500，这是以太网的默认值。</li></ul><p>上一节，我们讲过网络包是层层封装的。MTU 是二层 MAC 层的概念。MAC 层有 MAC 的头，以太网规定连 MAC 头带正文合起来，不允许超过 1500 个字节。正文里面有 IP 的头、TCP 的头、HTTP 的头。如果放不下，就需要<strong>分片来传输</strong>。</p><p><strong>qdisc pfifo_fast</strong> 是什么意思呢？<strong>qdisc</strong> 全称是<strong>queueing discipline</strong>，中文叫<strong>排队规则</strong>。内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的 qdisc（排队规则）把数据包加入队列。  </p><p>最简单的 qdisc 是 <strong>pfifo</strong>，它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。<strong>pfifo_fast</strong> 稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用<strong>先进先出规则</strong>。  </p><p>三个波段（band）的优先级也不相同。band 0 的优先级最高，band 2 的最低。如果 band 0 里面有数据包，系统就不会处理 band 1 里面的数据包，band 1 和 band 2 之间也是一样。  </p><p>数据包是按照服务类型（<strong>Type of Service，TOS</strong>）被分配多三个波段（band）里面的。TOS 是 IP 头里面的一个字段，代表了当前的包是高优先级的，还是低优先级的。</p><h1 id="知识复盘"><a href="#知识复盘" class="headerlink" title="知识复盘"></a>知识复盘</h1><h2 id="IP地址五大类作用于何处？"><a href="#IP地址五大类作用于何处？" class="headerlink" title="IP地址五大类作用于何处？"></a>IP地址五大类作用于何处？</h2><p>A类保留给政府机构，B类分配给中等规模的公司，C类分配给任何需要的人，D类用于组播，E类用于实验，各类可容纳的地址数目不同。</p><h2 id="IP设计时犯的错误？"><a href="#IP设计时犯的错误？" class="headerlink" title="IP设计时犯的错误？"></a>IP设计时犯的错误？</h2><p>低估了未来网络的发展，32位地址不够用。于是有了现在IPv6（128位） 分类错误。分成了5类。C类太少，B类太多。C类254个，网络都不够；D类6万多，给企业都太多。 </p><h2 id="那后来者如何弥补IP设计者犯的错误呢？"><a href="#那后来者如何弥补IP设计者犯的错误呢？" class="headerlink" title="那后来者如何弥补IP设计者犯的错误呢？"></a>那后来者如何弥补IP设计者犯的错误呢？</h2><p> <strong>CIDR，无类型域间选路。</strong><br>    打破原来几类地址设计的做法，将32位IP地址一分二，前者网络号，后者主机号。  如何分呢？<br>     例子：10.100.122.2/24    前24位是网络号，那么后8位就是主机号。  那如何用？  如发送行信息给 10.100.122.255 所有以 10.100.122… 开头的机器都能收到。<br>     于是有了两个概念：<br>     广播地址：10.100.122.255 子网掩码：255.255.255.0。</p><h2 id="每一个城市都有人民广场，IP设计是如何解决的？"><a href="#每一个城市都有人民广场，IP设计是如何解决的？" class="headerlink" title="每一个城市都有人民广场，IP设计是如何解决的？"></a>每一个城市都有人民广场，IP设计是如何解决的？</h2><p><strong>公有IP地址和私有IP地址</strong>。<br> 搭建世界人民都可以访问的网站，需要共有IP地址 搭建只有学校同学使用饿的网站，只要私有IP地址<br>例子1: Wi-Fi 192.168.0.x 是最常用的私有 IP 地址 192.168.0 是网络号 192.168.0.1，往往就是你这个私有网络的出口地址 192.168.0.255 就是广播地址。一旦发送这个地址，整个 192.168.0 网络里面的所有机器都能收到。  </p><h2 id="如何理解MAC地址？"><a href="#如何理解MAC地址？" class="headerlink" title="如何理解MAC地址？"></a>如何理解MAC地址？</h2><p><strong>IP是地址，有定位功能；Mac就是身份证，唯一识别</strong>。   </p><h2 id="IP地址scope是什么意思？"><a href="#IP地址scope是什么意思？" class="headerlink" title="IP地址scope是什么意思？"></a>IP地址scope是什么意思？</h2><p>对于 eth0 这张网卡来讲，是 global，说明这张网卡是可以对外的，可以接收来自各个地方的包。对于 lo 来讲，是 host，说明这张网卡仅仅可以供本机相互通信。  </p><h2 id="lo是什么意思？"><a href="#lo是什么意思？" class="headerlink" title="lo是什么意思？"></a>lo是什么意思？</h2><p>lo 全称是loopback，又称<strong>环回接口</strong>，往往会被分配到 127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。  </p><h2 id="BROADCAST-MULTICAST-UP-LOWER-UP-gt-是干什么的？"><a href="#BROADCAST-MULTICAST-UP-LOWER-UP-gt-是干什么的？" class="headerlink" title="BROADCAST,MULTICAST,UP,LOWER_UP &gt; 是干什么的？"></a>BROADCAST,MULTICAST,UP,LOWER_UP &gt; 是干什么的？</h2><ul><li>net_device flags，网络设备的状态标识</li><li>UP 表示网卡处于启动的状态</li><li>BROADCAST 表示这个网卡有广播地址，可以发送广播包</li><li>MULTICAST 表示网卡可以发送多播包</li><li>LOWER_UP 表示 L1 是启动的，也即网线插着</li></ul><h2 id="MTU1500-是指什么意思呢？是哪一层的概念？"><a href="#MTU1500-是指什么意思呢？是哪一层的概念？" class="headerlink" title="MTU1500 是指什么意思呢？是哪一层的概念？"></a>MTU1500 是指什么意思呢？是哪一层的概念？</h2><ul><li>最大传输单元 MTU 为 1500，这是以太网的默认值。</li></ul><ul><li>MTU 是二层 MAC 层的概念。</li><li>MAC 层有 MAC 的头，以太网规定连 MAC 头带正文合起来，不允许超过 1500 个字节。</li></ul><ul><li>qdisc pfifo_fast 是什么意思呢？<br>排队规则。规定数据包如何进出的。有pfifo, pfifo_fast.</li></ul><h1 id="额外知识"><a href="#额外知识" class="headerlink" title="额外知识"></a>额外知识</h1><h2 id="一个C类地址最大能表示256个IP地址，为什么最多能连254台主机？"><a href="#一个C类地址最大能表示256个IP地址，为什么最多能连254台主机？" class="headerlink" title="一个C类地址最大能表示256个IP地址，为什么最多能连254台主机？"></a>一个C类地址最大能表示256个IP地址，为什么最多能连254台主机？</h2><p>因为存在<strong>广播地址</strong>和<strong>网络地址</strong>（不可用）</p><h2 id="如何得出网络地址、广播地址？"><a href="#如何得出网络地址、广播地址？" class="headerlink" title="如何得出网络地址、广播地址？"></a>如何得出网络地址、广播地址？</h2><ul><li>子网掩码和IP地址的进行二进制“与”运算，得出出网络地址</li><li>网络地址二进制后连续的0栋变成1就是广播地址</li></ul><h2 id="如何计算子网数、主机数？"><a href="#如何计算子网数、主机数？" class="headerlink" title="如何计算子网数、主机数？"></a>如何计算子网数、主机数？</h2><ul><li>子网数=2^（实际网络号位数 – 地址类型网络号位数）</li><li>主机数=2^主机号</li></ul><h2 id="为什么-子网掩码-必须由连续的-1-和-0-组成？"><a href="#为什么-子网掩码-必须由连续的-1-和-0-组成？" class="headerlink" title="为什么 子网掩码 必须由连续的 1 和 0 组成？"></a>为什么 子网掩码 必须由连续的 1 和 0 组成？</h2><p>因为<strong>继承的连续性</strong>，证明这个子网是这个网段的，不认错爸<br>知乎回答：<a href="https://www.zhihu.com/question/285680797" target="_blank" rel="noopener">https://www.zhihu.com/question/285680797</a></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>可以使用ifconfig或ip addr查看地址</li><li>IP地址分为五大类，后使用CIDR重构规则，以解决地址耗尽</li><li>CIDR聚合多个子网地址合成一个超网地址以减少核心路由器运载，使能够更自由的分配主机数</li><li>根据子网掩码可以得出IP地址的网络号和主机号，在CIDR中还能得出网络地址、广播地址、子网数和主机数等</li><li>scope表示一个范围，它是ip地址的属性，后面要是global表示该网卡对外通信，host对内通信</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;恩，熟悉的陌生人&lt;/p&gt;
    
    </summary>
    
      <category term="网络协议" scheme="http://itfriends.xyz/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议" scheme="http://itfriends.xyz/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>【网络协议】笔记二 | 网络分层的真实含义</title>
    <link href="http://itfriends.xyz/2018/07/24/%E3%80%90%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%91%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%9A%84%E7%9C%9F%E5%AE%9E%E5%90%AB%E4%B9%89/"/>
    <id>http://itfriends.xyz/2018/07/24/【网络协议】笔记二：网络分层的真实含义/</id>
    <published>2018-07-24T10:22:47.000Z</published>
    <updated>2018-07-26T15:51:36.198Z</updated>
    
    <content type="html"><![CDATA[<p>太复杂，就分工</p><a id="more"></a><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>网络分层</li><li>数据包处理程序</li><li>TCP握手的背后</li></ul><h2 id="网络为什么分层？"><a href="#网络为什么分层？" class="headerlink" title="网络为什么分层？"></a>网络为什么分层？</h2><p><strong>因为是个复杂的程序都要分层，这是程序设计的要求, 涉及到架构和设计模式的问题，分层是各个模块业务逻辑的职责划分。</strong></p><h2 id="处理网络数据包的程序是如何工作的？"><a href="#处理网络数据包的程序是如何工作的？" class="headerlink" title="处理网络数据包的程序是如何工作的？"></a>处理网络数据包的程序是如何工作的？</h2><p><strong>客户端和服务器就像没有天桥的双子楼，要从A座的24层到达B座24层就得先下楼梯再上楼梯</strong></p><p> <img src="https://img-blog.csdn.net/20180724181548535?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br><strong>发送请求</strong>：<strong>封包</strong></p><ol><li>点击网页，发起HTTP请求,浏览器使用端口号发送。</li><li>添加TCP头，记录下源端口号。浏览器给出目的端口号，一般为80端口。</li><li>添加IP头，记录下源IP地址和目标IP地址。</li><li>添加MACtou，记录源MAC地址和目标MAC地址，目标MAC地址如果不知道，需要通过一定的协议处理过程（玄奘西行），找到MAC地址。</li><li>网口发出。</li></ol><p><strong>接受请求</strong>：<strong>拆包</strong></p><ol><li>经过网口。</li><li>判断mac地址是否是自己，不是则不接收。</li><li>判断IP地址是否是自己的，不是则转发。</li><li>判断地址是TCP还是UDP进行不同的逻辑处理。假设这个地址是 TCP<br>的，则会调用process_tcp(buffer)。这时候，Buffer<br>里面没有三层的头，就需要查看四层的头，看这是一个发起，还是一个应答，又或者是一个正常的数据包，然后分别由不同的逻辑进行处理。如果是发起或者应答，接下来可能要发送一个回复包；如果是一个正常的数据包，就需要交给上层了。判断哪个应用处理，在四层的头里面有端口号，不同的应用监听不同的端口号。</li><li>浏览器解析HTML，显示页面。</li></ol><h2 id="TCP-在三次握手的时候，IP-层和-MAC-层在做什么呢"><a href="#TCP-在三次握手的时候，IP-层和-MAC-层在做什么呢" class="headerlink" title="TCP 在三次握手的时候，IP 层和 MAC 层在做什么呢?"></a>TCP 在三次握手的时候，IP 层和 MAC 层在做什么呢?</h2><p><strong>TCP 发送每一个消息，都会带着 IP 层和 MAC 层了。</strong><br>因为，TCP 每发送一个消息，IP 层和 MAC 层的所有机制都要运行一遍。<br><strong>记住</strong>：只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。<br>所以，对 TCP 协议来说，三次握手也好，重试也好，只要想发出去包，就要有 IP 层和 MAC 层，不然是发不出去的。<br><strong>如同跨越没有天桥的双子楼，从A栋的4楼跑去B栋的4楼都需要经过下楼、上楼的步骤，把4楼以下的楼层跑一次。</strong></p><h2 id="知识复盘"><a href="#知识复盘" class="headerlink" title="知识复盘"></a>知识复盘</h2><h1 id="网络为什么要分层？"><a href="#网络为什么要分层？" class="headerlink" title="网络为什么要分层？"></a>网络为什么要分层？</h1><p>太复杂</p><h1 id="处理网络数据包的程序是如何工作的？-1"><a href="#处理网络数据包的程序是如何工作的？-1" class="headerlink" title="处理网络数据包的程序是如何工作的？"></a>处理网络数据包的程序是如何工作的？</h1><p>像个没有天桥的双子楼，到达服务器就要先封包下楼再拆包上楼</p><h1 id="TCP在三次握手的时候，IP层和MAC层在做什么？"><a href="#TCP在三次握手的时候，IP层和MAC层在做什么？" class="headerlink" title="TCP在三次握手的时候，IP层和MAC层在做什么？"></a>TCP在三次握手的时候，IP层和MAC层在做什么？</h1><p>IP层和MAC层所有机制都要运行一遍，封包下楼、拆包上楼</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>网络程序分层处理，下楼封包、上楼拆包</li><li>MAC地址对上就上楼，IP地址不对就从楼中丢出去</li><li>楼层（TCP）与对面楼层之间不能飞跃而过，该怎么走就怎么走</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;太复杂，就分工&lt;/p&gt;
    
    </summary>
    
      <category term="网络协议" scheme="http://itfriends.xyz/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议" scheme="http://itfriends.xyz/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>【网络协议】笔记一 | 为什么要学习网络协议？</title>
    <link href="http://itfriends.xyz/2018/07/23/%E3%80%90%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%91%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%9F/"/>
    <id>http://itfriends.xyz/2018/07/23/【网络协议】笔记一：为什么要学习网络协议？/</id>
    <published>2018-07-23T06:53:28.000Z</published>
    <updated>2018-07-26T15:51:47.958Z</updated>
    
    <content type="html"><![CDATA[<p>为了打造互联网世界的通天塔<br><a id="more"></a></p><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>协议三要素</li><li>常用的网络协议</li><li>网络数据包结构</li><li>一次玄奘西行</li></ul><h1 id="为什么要学习网络协议？"><a href="#为什么要学习网络协议？" class="headerlink" title="为什么要学习网络协议？"></a>为什么要学习网络协议？</h1><p>只有通过网络协议，才能使一大片机器互相协作、共同完成一件事。</p><h1 id="协议三要素"><a href="#协议三要素" class="headerlink" title="协议三要素"></a>协议三要素</h1><p>例如编写代码打印“<strong>hello world</strong>”也是人类和计算机沟通的协议，需要经过编译成机器可识别文件执行 。<br>不同的计算机之间必须使用相同的网络协议才能进行通信。<br><img src="https://img-blog.csdn.net/20180723144133482?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br><strong>语法</strong>：“<strong>如何讲</strong>”，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。<br><strong>语义</strong>：“<strong>讲什么</strong>”，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。<br><strong>顺序</strong>：“<strong>讲啥先</strong>”，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值。</p><p>比如浏览器上展示网页内容：<br>它之所以能够显示缤纷多彩的页面，是因为它收到了一段来自 HTTP协议的“东西”，例如网易考拉，格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span>: Tue, 27 Mar 2018 16:50:26 GMT</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html;charset=UTF-8</span><br><span class="line"><span class="attribute">Content-Language</span>: zh-CN</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;base href="https://pages.kaola.com/" /&gt;</span><br><span class="line">&lt;meta charset="utf-8"/&gt; &lt;title&gt; 网易考拉 3 周年主会场 &lt;/title&gt;</span><br></pre></td></tr></table></figure><p><strong>首先，符合语法。</strong><br>只有按照上面那个格式来，浏览器才认。例如，上来是状态，然后是首部，然后是内容。<br><strong>然后，符合语义。</strong><br>就是要按照约定的意思来。例如，状态 200，表述的意思是网页成功返回。如果不成功，就是我们常见的“404”。<br><strong>最后，符合顺序。</strong><br>点击浏览器，就是发送出一个 HTTP 请求，然后才有上面那一串 HTTP 返回的东西。<br>浏览器显然按照协议商定好的做了，最后一个五彩缤纷的页面就出现在你面前了。</p><h1 id="常用的网络协议"><a href="#常用的网络协议" class="headerlink" title="常用的网络协议"></a>常用的网络协议</h1><p><strong>DNS协议、HTTP协议、HTTPS协议、TCP/IP协议、IP协议、DHCP协议、ARP协议**</strong>等**<br>比如网上的一次点击购物的请求包含：</p><p><img src="https://img-blog.csdn.net/20180723144324800?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>图上5层，从下往上一层层封装：<br><strong>第一层</strong>：<strong>是什么</strong><br><strong>第二层</strong>：<strong>啥样式</strong></p><ul><li>DNS、HTTP、HTTPS 所在的层我们称为应用层。</li><li>经过应用层封装后，浏览器会将应用层的包交给下一层去完成，通过socket 编程来实现</li></ul><p><strong>第三层</strong>：<strong>咋处理</strong></p><ul><li>传输层有两种协议，一种是无连接的协议<em>UDP</em>（发短信），一种是面向连接的协议TCP（打电话）</li><li>TCP 协议里面会有两个端口，一个是浏览器监听的端口，一个是电商的服务器监听的端口。操作系统往往通过端口来判断，它得到的包应该给哪个进程。<br>传输层封装完毕后，浏览器会将包交给操作系统的网络层</li></ul><p><strong>第四层</strong>：<strong>交给谁</strong></p><ul><li>网络层的协议是 IP 协议。</li><li>IP 协议里面会有源 IP 地址，即浏览器所在机器的 IP 地址和目标 IP 地址，也即电商网站所在服务器的 IP 地址。</li></ul><p><strong>第五层</strong>：<strong>先去哪</strong></p><ul><li>操作系统根据IP这个门牌号判断是内地人还是外地人的，去外地就要经过网关。</li><li>而操作系统启动的时候，就会被 DHCP 协议配置 IP 地址，以及默认的网关的 IP 地址 。</li><li>操作系统发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理MAC地址。</li><li>于是操作系统将 IP 包交给了下一层，也就是MAC 层。</li><li>由于这个包里面是有 MAC 地址的，因而它能够到达网关。</li></ul><p>网关往往是一个路由器，到某个 IP 地址应该怎么走，这个叫作<strong>路由表</strong>。</p><h1 id="玄奘西行"><a href="#玄奘西行" class="headerlink" title="玄奘西行"></a>玄奘西行</h1><ul><li>一次购物请求的整个过程如同玄奘西行，不断经过国家的<strong>城关</strong>（路由器）；<br>每个城关连着两个<strong>国家</strong>（局域网），一旦跨越城关，就需要拿出<strong>通关文牒</strong>（数据包中包含源IP地址）并询问接下来该如何走，每个城关都知道下一个城关怎么走；</li><li>当城关通过通关文牒知道<strong>目的地</strong>（目标IP）在自己邻接的国家中，就好发起<strong>通告</strong>（广播）寻找，然后得到<strong>回复</strong>（目标MAC地址），然后就可以到达<strong>天竺</strong>（目标服务器）了；</li><li>然后天竺确认你确实是找天竺的（在城关寻得的MAC地址对得上），再确认你寻的真经是在天竺的（IP地址对得上），最后让人寻真经给你（IP 头里会写上一层封装的是 TCP 协议，然后将其交给传输层，即TCP层）；</li><li>西行路上千难万险，因此到了得<strong>报个平安</strong>（仅仅是 TCP 层的一个说明，原路返回，如果过段时间还没回复，不断重发，知道平安到达的回复，tcp的三次握手）。</li></ul><p>城关：<br> <img src="https://img-blog.csdn.net/20180723144604395?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br> <img src="https://img-blog.csdn.net/20180723144613710?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br> 流程：<br> <img src="https://img-blog.csdn.net/20180723144628273?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h1 id="有IP地址为什么还需要MAC地址？"><a href="#有IP地址为什么还需要MAC地址？" class="headerlink" title="有IP地址为什么还需要MAC地址？"></a>有IP地址为什么还需要MAC地址？</h1><p><strong>IP地址可以变动，而MAC地址是唯一的。</strong><br><strong>IP是个人地址，MAC是个人身份证，地址可以变更，但身份证不行。</strong><br><strong>到达了个人地址还需要确认身份证，才能证明找的是本人。</strong></p><p>当网络包到达一个城关的时候，可以通过路由表得到下一个城关的 IP 地址，直接通过 IP 地址找就可以了，为什么还要通过本地的 MAC 地址呢？</p><ol><li>局域网内IP地址是动态分配的，假如我是192.168.2.100，如果我下线了，可能IP就分配给了另一台电脑。IP和设备并不总是对应的，这对通信就产生了问题，但是MAC地址不同，MAC地址和设备是一一对应且全球唯一的。所以局域网使用MAC地址通信没有问题。</li><li>历史遗留问题：早期的以太网只有交换机，没有路由器，以太网内通过MAC地址通信。后来才有了互联网，为了兼容原本的模式，采用了IP+MAC地址通信的方式。为啥不推到了重来呢？看看IPv6的处境你就知道了。所以是先有MAC地址后有的IP，IP的提出主要还是因为MAC地址本身的缺陷，这个问题换成有了MAC为何还要IP地址也很有意思。</li><li>第一：MAC地址本身的缺陷：因为MAC地址是硬件提供商写在网卡中的，MAC地址虽然唯一但是不能表明用户在整个互联网中的位置，除非维护一个超级大MAC地址对应表，那寻址效率肯定爆炸。但是IP地址解决了这个问题，因为IP地址是网络提供商给你的，所以你在哪里整个网络都是知道的。<br>第二：安全问题：获取MAC地址是通过ARP协议来完成的，如果只用MAC地址通信，那么广播风暴是个难题。</li><li>猜想：如果哪天每人一个固定的IPv6地址，那么MAC地址+IPv4的模式是不是可以被替换了？</li><li>其实手机通过数据上网就是一个通过类似mac寻址的一个网络。在移动网络中是允许你移动的，这是由于基站会记录你的位置信息。并且核心网与公网的通信是通过ip来实现的，而在手机和基站间的通信是通过类似mac的一个唯一码实现的。并且移动网络整体建设成本比互联网的成本高很多，消费也高很多。</li></ol><h1 id="为什么mac地址是全世界唯一的？"><a href="#为什么mac地址是全世界唯一的？" class="headerlink" title="为什么mac地址是全世界唯一的？"></a>为什么mac地址是全世界唯一的？</h1><p><strong>网卡MAC码是由全球惟一的一个固定组织来分配的，未经认证和授权的厂家无权生产网卡</strong>。<br>每块网卡都有一个固定的卡号，并且任何正规厂家生产的网卡上都直接标明了卡号，一般为一组12位的16进制数。其中前6位代表网卡的生产厂商。后面的位数是设备号。当然在操作系统级别改Mac地址又是一种说法。</p><h1 id="知识复盘"><a href="#知识复盘" class="headerlink" title="知识复盘"></a>知识复盘</h1><h2 id="为什么要学习网络协议？-1"><a href="#为什么要学习网络协议？-1" class="headerlink" title="为什么要学习网络协议？"></a>为什么要学习网络协议？</h2><p>能使一大片机器互相协作、共同完成一件事</p><h2 id="协议三要素是什么？"><a href="#协议三要素是什么？" class="headerlink" title="协议三要素是什么？"></a>协议三要素是什么？</h2><p>语法、语义、顺序</p><h2 id="一个网络请求包都包括啥？"><a href="#一个网络请求包都包括啥？" class="headerlink" title="一个网络请求包都包括啥？"></a>一个网络请求包都包括啥？</h2><p>是什么、啥样式、咋处理、交给谁、先去哪</p><h2 id="如何形象描述一次网络请求？"><a href="#如何形象描述一次网络请求？" class="headerlink" title="如何形象描述一次网络请求？"></a>如何形象描述一次网络请求？</h2><p>玄奘西行</p><h2 id="有IP地址为什么还需要MAC地址？-1"><a href="#有IP地址为什么还需要MAC地址？-1" class="headerlink" title="有IP地址为什么还需要MAC地址？"></a>有IP地址为什么还需要MAC地址？</h2><ul><li><strong>IP是个人地址，MAC是个人身份证</strong></li><li>为什么mac地址是全世界唯一的</li><li>网卡MAC码是由全球惟一的一个固定组织来分配的</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>机器之间只有达成<strong>协议</strong>才能通信协作</li><li>一次网络请求如同一次玄奘西行，长途跋涉</li></ul><p>————————————————————————————————————————<br>以上笔记学习于“极客时间”APP专栏，部分内容选自专栏评论。<br><img src="https://img-blog.csdn.net/20180723151726405?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了打造互联网世界的通天塔&lt;br&gt;
    
    </summary>
    
      <category term="网络协议" scheme="http://itfriends.xyz/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议" scheme="http://itfriends.xyz/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Python 简单关键字爬取微信公众号文章</title>
    <link href="http://itfriends.xyz/2018/06/26/Python-%E7%AE%80%E5%8D%95%E5%85%B3%E9%94%AE%E5%AD%97%E7%88%AC%E5%8F%96%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    <id>http://itfriends.xyz/2018/06/26/Python-简单关键字爬取微信公众号文章/</id>
    <published>2018-06-26T04:41:01.000Z</published>
    <updated>2018-07-23T09:49:10.444Z</updated>
    
    <content type="html"><![CDATA[<p>记录一次爬虫作业项目<br><a id="more"></a></p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><strong>爬取目标</strong>：微信公众号“纵梦广科”中“表白墙”（可选“吐槽墙”）的文章<br><strong>爬取字段</strong>：表白对象、表白内容<br><strong>爬取缘由</strong>：分析“表白墙”上的同学什么说得多的词<br><strong>爬取工具</strong>：matplotlib、wordcloud、jieba<br><strong>爬取结果</strong>: “表白墙”文章160篇<br><strong>爬取收获</strong>：简单爬取公众号文章、简单生成词云<br><strong>爬取注意</strong>：</p><ul><li>因为爬取内容可以简洁地直接保存txt文本进行绘画<strong>词云</strong>分析，所有并没有存入数据库</li><li>本项目代码<strong>不具有可复用性</strong>，无论是登录的<strong>cookie</strong>还是文章的<strong>页数</strong>都需要重新手动获取输入</li><li>代码中cookie的值太长了，都在一行不方便阅读，于是做了分行，可以根据个人喜好选择</li><li>本代码通用于爬取公众号文章的<strong>标题</strong>和<strong>url</strong>，如需要爬取文章内容则需要手动更改爬取规则</li><li><strong>token</strong>的值是爬取的公众号的标识符，如果更换公众号就需要更改该值</li><li>本项目代码因为“表白墙”与“吐槽墙”网页结构相同，因此可以自行选择输入“表白墙”或“吐槽墙”进行爬取</li><li>词云图在本文档后面</li><li>获取cookie等操作步骤在本文最后</li></ul><p><strong>ps:</strong><br>在参考文章中的例子是直接搜索公众号全部内容文章的，我测试过这样爬取全部的话只能爬几页就被提示”操作太频繁“而无法爬取，但换成关键字”query”搜索的话没有出现问题，目前本代码爬取”表白墙“32页并没有本禁止。本来还尝试如何避免封装爬取全部文章但没有成功，但如果关键字是空白符或者其他标点符号的话也能获取大部分文章</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Cookie，跳过登陆操作</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"Cookie"</span>: <span class="string">"noticeLoginFlag=1; remember_acct=820605644%40qq.com; "</span></span><br><span class="line">              <span class="string">"ua_id=F89e6CvMPIib8tkPAAAAAE8A9_O5KrS5oMM390XQRHI=; mm_lang=zh_CN; pgv_pvi=1996118016; "</span></span><br><span class="line">              <span class="string">"noticeLoginFlag=1; remember_acct=820605644%40qq.com; pgv_si=s2063726592; ticket_id=gh_86437b3d3630; "</span></span><br><span class="line">              <span class="string">"cert=3RRm40LWsECquCbg_jx5lQTMXRR4M0tN; rewardsn=; wxtokenkey=777; "</span></span><br><span class="line">              <span class="string">"uuid=652947b257247d453cd64dc13a5daf0b; ticket=d19dbee738a3be7f0806c8a5f726b8d8cac125f6; "</span></span><br><span class="line">              <span class="string">"data_bizuin=3555601673; bizuin=3551846274; "</span></span><br><span class="line">              <span class="string">"data_ticket=eeN9lRUD61DWiiLZEJyFKGoi70SoJ2dB1BoNi4PnSvNaf6R3jA83ZYyEI1y3LaOU; "</span></span><br><span class="line">              <span class="string">"slave_sid"</span></span><br><span class="line">              <span class="string">"=elBZTHhvYlc0VmNnYTM0SnZ6Wl9DaGZTNWh0M0VZVHlxUDBfWHNUW"</span></span><br><span class="line">              <span class="string">"jFVbEpOcFpmWEpuNUFXTEdGRWI5a3p6OGhrUWYweExnNjN2d0xMUWEwTVlLVWxIWk9mXzhzbkYxWndCQUVYTm"</span></span><br><span class="line">              <span class="string">"l1UnVxYlNWbmR3Q09VT2pMbEFMZDNhOFhXTnRnMlpDbDhvYzZWN2hQ;"</span></span><br><span class="line">              <span class="string">" slave_user=gh_86437b3d3630; xid=a5467f49610c64af7a7022c6a4596f40; "</span></span><br><span class="line">              <span class="string">"openid2ticket_oCS3u05exHidsZqiS_3Q8Yn-YtYI=JjxfUwXvqw0VBHJhW5TvmrOn8W5QMp/ReaanapVptWI="</span>,</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) "</span></span><br><span class="line">                  <span class="string">"Chrome/65.0.3325.162 Safari/537.36"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 词云</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_word</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    创建词云图片，默认样式</span></span><br><span class="line"><span class="string">    :param f:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    text_from_file_with_apath = open(f, <span class="string">'rb'</span>).read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    wordlist_after_jieba = jieba.cut(text_from_file_with_apath, cut_all=<span class="keyword">True</span>)</span><br><span class="line">    print(wordlist_after_jieba)</span><br><span class="line">    wl_space_split = <span class="string">" "</span>.join(wordlist_after_jieba)</span><br><span class="line">    alice_mask = np.array(Image.open(<span class="string">"girl.jpg"</span>))  <span class="comment"># 以数组的形式加载图画</span></span><br><span class="line">    my_wordcloud = WordCloud(font_path=<span class="string">"simhei.ttf"</span>,  <span class="comment"># 设置字体</span></span><br><span class="line">                             background_color=<span class="string">"white"</span>,  <span class="comment"># 背景颜色</span></span><br><span class="line">                             max_words=<span class="number">2000</span>,  <span class="comment"># 词云显示的最大词数</span></span><br><span class="line">                             mask=alice_mask,  <span class="comment"># 设置背景图片</span></span><br><span class="line">                             max_font_size=<span class="number">100</span>,  <span class="comment"># 字体最大值</span></span><br><span class="line">                             random_state=<span class="number">42</span>,</span><br><span class="line">                             margin=<span class="number">2</span>,  <span class="comment"># 设置图片默认的大小,但是如果使用背景图片的话,那么保存的图片大小将会按照其大小保存,margin为词语边缘距离</span></span><br><span class="line">                             ).generate(wl_space_split)</span><br><span class="line">    plt.imshow(my_wordcloud)</span><br><span class="line">    plt.axis(<span class="string">"off"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_info</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取文章中的吐槽对象和吐槽内容</span></span><br><span class="line"><span class="string">    :param url:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    res = requests.get(url, headers=headers)</span><br><span class="line">    selector = etree.HTML(res.text)</span><br><span class="line">    names = selector.xpath(<span class="string">'// *[ @ id = "js_content"] // section / section[2] / section / span / span / text()'</span>)</span><br><span class="line">    contents = selector.xpath(<span class="string">'// *[ @ id = "js_content"] // section / section[2] / section / text()'</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'name.txt'</span>, <span class="string">'ab+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> names:</span><br><span class="line">            f.write(s.strip().encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'content.txt'</span>, <span class="string">'ab+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> contents:</span><br><span class="line">            f.write(s.strip().encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'content.txt'</span>, <span class="string">'name.txt'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_list</span><span class="params">(url, input_name, post_num)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取每页搜索结果的json中文章的标题和url</span></span><br><span class="line"><span class="string">    :param url:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(post_num):</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">"token"</span>: <span class="number">1111467131</span>,</span><br><span class="line">            <span class="string">"lang"</span>: <span class="string">"zh_CN"</span>,</span><br><span class="line">            <span class="string">"f"</span>: <span class="string">"json"</span>,</span><br><span class="line">            <span class="string">"ajax"</span>: <span class="string">"1"</span>,</span><br><span class="line">            <span class="string">"action"</span>: <span class="string">"list_ex"</span>,</span><br><span class="line">            <span class="string">"begin"</span>: num * <span class="number">5</span>,</span><br><span class="line">            <span class="string">"random"</span>: <span class="number">0.040206335386987035</span>,</span><br><span class="line">            <span class="string">"count"</span>: <span class="string">"5"</span>,</span><br><span class="line">            <span class="string">"query"</span>: input_name,</span><br><span class="line">            <span class="string">"fakeid"</span>: <span class="string">"MzAwMzExNTQyNQ=="</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"9"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 使用get方法进行提交</span></span><br><span class="line">        content_json = requests.get(url, headers=headers, params=data).json()</span><br><span class="line">        <span class="comment"># 返回了一个json，里面是每一页的数据</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> content_json[<span class="string">"app_msg_list"</span>]:</span><br><span class="line">            <span class="comment"># 提取每页文章的标题及对应的url</span></span><br><span class="line">            print(item[<span class="string">"title"</span>], <span class="string">"url:"</span>, item[<span class="string">"link"</span>])</span><br><span class="line">            f1, f2 = get_info(item[<span class="string">"link"</span>])</span><br><span class="line">        time.sleep(random.randint(<span class="number">0</span>, <span class="number">30</span>))</span><br><span class="line">    <span class="keyword">return</span> f1, f2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标url</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    input_name = <span class="string">"表白墙"</span>  <span class="comment"># 表白墙或吐槽墙任选其一</span></span><br><span class="line">    url = <span class="string">"https://mp.weixin.qq.com/cgi-bin/appmsg"</span></span><br><span class="line">    f1, f2 = get_list(url, input_name, post_num=<span class="number">32</span>)</span><br><span class="line">    get_word(f1)  <span class="comment"># 创建词云</span></span><br><span class="line">    get_word(f2)</span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>公众号截图：<br> <img src="https://img-blog.csdn.net/2018062516322643?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br> <img src="https://img-blog.csdn.net/20180625163237435?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>表白内容词云：<br> <img src="https://img-blog.csdn.net/20180625163247521?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>表白对象词云：<br><img src="https://img-blog.csdn.net/20180625163256520?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>1、拥有一个微信个人订阅号，附上登陆和注册链接。<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">微信公众平台</a></p><p>2、好在之前无聊注册过一次，所以就可以直接登陆操作。没有注册的童鞋可以用自己的微信号注册一下，过程十分简单，在此就不赘述了</p><p>3、登陆之后，点击左侧菜单栏“管理”-“素材管理”。再点击右边的“新建图文素材”</p><p><img src="https://img-blog.csdn.net/20180626123134321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>​弹出一个新的标签页，在上面的工具栏找到“超链接”并点击<br><img src="https://img-blog.csdn.net/20180626123141956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>弹出了一个小窗口，选择“查找文章”，输入需要查找的公众号<br><img src="https://img-blog.csdn.net/20180626123257615?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>点击之后，可以弹出该公众号的所有历史文章<br><img src="https://img-blog.csdn.net/20180626123346447?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>关键字搜索、页数<br><img src="https://img-blog.csdn.net/20180626123421257?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h2 id="查看cookie"><a href="#查看cookie" class="headerlink" title="查看cookie"></a>查看cookie</h2><p><img src="https://img-blog.csdn.net/20180723174827873?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h2 id="查看token"><a href="#查看token" class="headerlink" title="查看token"></a>查看token</h2><p><img src="https://img-blog.csdn.net/20180723174841355?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>本文部分参考该博友的文章：<a href="https://blog.csdn.net/wnma3mz/article/details/78570580" target="_blank" rel="noopener">https://blog.csdn.net/wnma3mz/article/details/78570580</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一次爬虫作业项目&lt;br&gt;
    
    </summary>
    
      <category term="爬虫" scheme="http://itfriends.xyz/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="http://itfriends.xyz/tags/Python/"/>
    
      <category term="爬虫" scheme="http://itfriends.xyz/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 设置首页隐藏指定文章</title>
    <link href="http://itfriends.xyz/2018/06/12/Hexo-%E8%AE%BE%E7%BD%AE%E9%A6%96%E9%A1%B5%E9%9A%90%E8%97%8F%E6%8C%87%E5%AE%9A%E6%96%87%E7%AB%A0/"/>
    <id>http://itfriends.xyz/2018/06/12/Hexo-设置首页隐藏指定文章/</id>
    <published>2018-06-12T14:32:27.000Z</published>
    <updated>2018-06-12T14:47:19.143Z</updated>
    
    <content type="html"><![CDATA[<p>有时候我们可能只想在首页显示关于编程之类的内容，而个人日记之类的文章放在其他分类之下而不在首页显示。可以从、分类、标签、归档中查看文章。<br><a id="more"></a></p><h1 id="自定义front-matter的参数"><a href="#自定义front-matter的参数" class="headerlink" title="自定义front-matter的参数"></a>自定义front-matter的参数</h1><p>例如，自定义添加一个<strong>notshow</strong>参数，值为<strong>true</strong>，用来提供判断</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">《好好学习》—黄金思维圈</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-06</span><span class="bullet">-12</span> <span class="number">11</span><span class="string">:45:43</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">read</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">read</span></span><br><span class="line"><span class="attr">notshow:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p><strong>front-matter</strong>就是每次<strong>hexo new “post_name”</strong>创建的文章里面的开头。<br>创建的文章存放在hexo根目录下的：<strong>source_posts</strong>中</p><h1 id="修改主题的index-swig"><a href="#修改主题的index-swig" class="headerlink" title="修改主题的index.swig"></a>修改主题的index.swig</h1><p>主题可能各不一样，但原理都是一样的，我拿我使用的<strong>next主题</strong>来示范。<br>路径：<strong>Hexo\themes\next\layout\index.swig</strong></p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> '_layout.swig' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">import</span> '_macro/post.swig' <span class="keyword">as</span> post_template %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">import</span> '_macro/sidebar.swig' <span class="keyword">as</span> sidebar_template %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"></span><span class="template-variable">&#123;&#123; config.title &#125;&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.index_with_subtitle and config.subtitle %&#125;</span><span class="xml"> - </span><span class="template-variable">&#123;&#123;config.subtitle &#125;&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_class %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> is_home() %&#125;</span><span class="xml">page-home</span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> -%&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> content %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"posts"</span> <span class="attr">class</span>=<span class="string">"posts-expand"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> post <span class="keyword">in</span> page.posts %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;&#123; post_template.render(post, true) &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endfor</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> '_partials/pagination.swig' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> sidebar %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="template-variable">&#123;&#123; sidebar_template.render(false) &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><p>修改这里：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> content %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"posts"</span> <span class="attr">class</span>=<span class="string">"posts-expand"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> post <span class="keyword">in</span> page.posts %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;&#123; post_template.render(post, true) &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endfor</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> '_partials/pagination.swig' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %</span></span><br></pre></td></tr></table></figure><p>改成：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> content %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"posts"</span> <span class="attr">class</span>=<span class="string">"posts-expand"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> post <span class="keyword">in</span> page.posts %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> post.notshow != true %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;&#123; post_template.render(post, true) &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endfor</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> '_partials/pagination.swig' %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><p>在for循环迭代文章中判断文章中的属性<strong>notshow</strong>，如果不为true就打印出文章。所以在需要隐藏的文章<strong>front-matter</strong>中添加<strong>notshow:true</strong>就可以了。</p><h1 id="添加自定义菜单"><a href="#添加自定义菜单" class="headerlink" title="添加自定义菜单"></a>添加自定义菜单</h1><p>比如我想在菜单栏添加一个“阅读”选项，但又不想新建自己一个页面，于是可以直接使用分类的页面。<br>创建新文章的时候直接指定<strong>categories: read</strong>配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">《好好学习》—黄金思维圈</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-06</span><span class="bullet">-12</span> <span class="number">11</span><span class="string">:45:43</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">read</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">read</span></span><br><span class="line"><span class="attr">notshow:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>在git中使用<strong>hexo g</strong>命令，hexo会在根目录<strong>/public/categrises</strong>下自动生成分类中的阅读文件夹<br>然后，<br>配置主题配置文件<strong>themes/_config.yml</strong>中添加以下代码（#号后为注释内容）</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">  home:</span> / || home</span><br><span class="line"><span class="symbol">  about:</span> <span class="meta-keyword">/about/</span> || user</span><br><span class="line"><span class="symbol">  tags:</span> <span class="meta-keyword">/tags/</span> || tags</span><br><span class="line"><span class="symbol">  categories:</span> <span class="meta-keyword">/categories/</span> || th</span><br><span class="line"><span class="symbol">  read:</span><span class="meta-keyword">/categories/</span>read  <span class="meta">#指定分类中阅读的路径</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180612223135662?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候我们可能只想在首页显示关于编程之类的内容，而个人日记之类的文章放在其他分类之下而不在首页显示。可以从、分类、标签、归档中查看文章。&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://itfriends.xyz/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://itfriends.xyz/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>《好好学习》—黄金思维圈</title>
    <link href="http://itfriends.xyz/2018/06/12/%E3%80%8A%E5%A5%BD%E5%A5%BD%E5%AD%A6%E4%B9%A0%E3%80%8B%E2%80%94%E9%BB%84%E9%87%91%E6%80%9D%E7%BB%B4%E5%9C%88/"/>
    <id>http://itfriends.xyz/2018/06/12/《好好学习》—黄金思维圈/</id>
    <published>2018-06-12T03:45:43.000Z</published>
    <updated>2018-06-12T05:15:48.903Z</updated>
    
    <content type="html"><![CDATA[<p>在古典老师的《超级个体》上，我接触到了2W1H的概念，然后在《结构思考力》中，我认识到了2W1H在工作中的分析问题的本质的用法,，而在《好好学习》中的“黄金思维圈”中，我更加清楚知道了，生活中做的每一件事都可以用2W1H去进行思考，也就是说善于问“为什么”，这样能够更好地看透问题的本质。</p><h1 id="黄金思维圈—我们看问题方式的三个层次"><a href="#黄金思维圈—我们看问题方式的三个层次" class="headerlink" title="黄金思维圈—我们看问题方式的三个层次"></a>黄金思维圈—我们看问题方式的三个层次</h1><p>第一层次是what层次：事情的表象，我们具体做的每一件事</p><p>第二层次是how层次：我们如何实现我们想要做的事</p><p>第三层次是why层次：我们为什么要这么做</p><a id="more"></a><h1 id="本章其他内容"><a href="#本章其他内容" class="headerlink" title="本章其他内容"></a>本章其他内容</h1><p>应聘者对于过去工作进行介绍</p><p>what：很多应聘者思考问题停留在what层面，就是只看到问题的表象</p><p>why：技术层面的时候有很多成熟的方法，给予时间训练就能提高，而思维方式的问题，因为涉及很多底层的假设和思维模式，如果没有一定的基础是难以改变的。</p><p>how：不是仅仅局限在工作内容本身，还能清晰第认识这个工作是在什么背景格局下产生的，为什么要完成这个工作，完成这个工作的关键是什么，突破口是什么…..</p><h1 id="销售的最高境界"><a href="#销售的最高境界" class="headerlink" title="销售的最高境界"></a>销售的最高境界</h1><p>销售你的价值观，也就是销售你的why——你为什么存在。</p><h1 id="关键语句"><a href="#关键语句" class="headerlink" title="关键语句"></a>关键语句</h1><p>伪需求看到的是需求的what层面，而真实的需求是要在what的表象之后挖掘到真正的why。</p><p>黄金思维圈最大的价值：透过问题的表象看到问题的本质</p><p>抓住why的本质，激发how的创意</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>《第五项修炼》：每个人不能只 囿于自己的岗位，觉得只做好分内之职就可以了，要对职位之间相互关联产生的结果富有一定责任。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在古典老师的《超级个体》上，我接触到了2W1H的概念，然后在《结构思考力》中，我认识到了2W1H在工作中的分析问题的本质的用法,，而在《好好学习》中的“黄金思维圈”中，我更加清楚知道了，生活中做的每一件事都可以用2W1H去进行思考，也就是说善于问“为什么”，这样能够更好地看透问题的本质。&lt;/p&gt;
&lt;h1 id=&quot;黄金思维圈—我们看问题方式的三个层次&quot;&gt;&lt;a href=&quot;#黄金思维圈—我们看问题方式的三个层次&quot; class=&quot;headerlink&quot; title=&quot;黄金思维圈—我们看问题方式的三个层次&quot;&gt;&lt;/a&gt;黄金思维圈—我们看问题方式的三个层次&lt;/h1&gt;&lt;p&gt;第一层次是what层次：事情的表象，我们具体做的每一件事&lt;/p&gt;
&lt;p&gt;第二层次是how层次：我们如何实现我们想要做的事&lt;/p&gt;
&lt;p&gt;第三层次是why层次：我们为什么要这么做&lt;/p&gt;
    
    </summary>
    
      <category term="read" scheme="http://itfriends.xyz/categories/read/"/>
    
    
      <category term="read" scheme="http://itfriends.xyz/tags/read/"/>
    
  </entry>
  
  <entry>
    <title>【Flask】flask核心机制：current_app</title>
    <link href="http://itfriends.xyz/2018/06/10/flask%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9Acurrent-app/"/>
    <id>http://itfriends.xyz/2018/06/10/flask核心机制：current-app/</id>
    <published>2018-06-10T15:11:13.000Z</published>
    <updated>2018-08-03T10:55:42.980Z</updated>
    
    <content type="html"><![CDATA[<p>加深了对于Flask中current_app的理解，弥补了Miguel Grinberg的教程略过的知识点。<br><a id="more"></a></p><p>原文地址:<a href="http://itfriends.xyz/2018/06/10/flask%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9Acurrent-app/#more">Flask核心机制：current_app</a></p><h1 id="核心知识"><a href="#核心知识" class="headerlink" title="核心知识"></a>核心知识</h1><ul><li>AppContext手动、自动入栈</li><li>LocalStack是线程隔离的栈结构</li><li>current_app是线程、协程隔离对象</li><li>LocalProxy是获取当前线程隔离的代理对象</li></ul><h1 id="flask中经典错误-working-outside-application-context"><a href="#flask中经典错误-working-outside-application-context" class="headerlink" title="flask中经典错误 working outside application context"></a>flask中经典错误 working outside application context</h1><p><strong>错误：</strong><br>working outside application contex<br><strong>原因：</strong><br>在没有获取到应用上下文的情况下，进行了上下文操作。<br><strong>代码：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, current_app</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">a = current_app</span><br><span class="line">d = current_app.config['DEBUG']</span><br></pre></td></tr></table></figure><p><strong>运行：</strong><br><img src="https://img-blog.csdn.net/201806102141266?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h1 id="AppContext、RequestContext、Flask与Request之间的关系"><a href="#AppContext、RequestContext、Flask与Request之间的关系" class="headerlink" title="AppContext、RequestContext、Flask与Request之间的关系"></a>AppContext、RequestContext、Flask与Request之间的关系</h1><p><strong>AppContext:</strong></p><ul><li>应用上下文，是对flask一切对象的封装<br><strong>RequestContext:</strong></li><li>请求上下文，是对request请求对象的封装<br><strong>current_app:</strong></li><li>类型是LocalProxy</li><li>像全局变量一样工作，但只能在处理请求期间且在处理它的线程中访问</li><li>返回的栈顶元素不是应用上下文，而是flask的应用实例对象</li></ul><p>应用上下文的封装=flask核心对象+和外部协作对象（再flask封装对象上再添加push、pop等）（请求上下文同理）<br><strong>代码：</strong><br>F12进入current_app</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># context locals</span><br><span class="line">_request_ctx_stack = LocalStack()</span><br><span class="line">_app_ctx_stack = LocalStack()</span><br><span class="line">current_app = LocalProxy(<span class="name">_find_app</span>)</span><br><span class="line">request = LocalProxy(<span class="name">partial</span>(<span class="name">_lookup_req_object</span>, 'request'))</span><br><span class="line">session = LocalProxy(<span class="name">partial</span>(<span class="name">_lookup_req_object</span>, 'session'))</span><br><span class="line">g = LocalProxy(<span class="name">partial</span>(<span class="name">_lookup_app_object</span>, 'g'))</span><br></pre></td></tr></table></figure><p><strong>current_app与reques：</strong><br>current_app和reques都是设计模式中代理设计的代理对象，指向flask核心对象和reques的请求类</p><h1 id="详解flask上下文与出入栈"><a href="#详解flask上下文与出入栈" class="headerlink" title="详解flask上下文与出入栈"></a>详解flask上下文与出入栈</h1><p><img src="https://img-blog.csdn.net/20180610215954276?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>在pycharm的flask项目中可以通过：<br><strong>External Libraries-&gt;site-packages-&gt;flask-&gt;ctx.py</strong><br>可以看到源码的实现<br>ctx.py中有<strong>AppContext</strong>、<strong>RequestContext</strong>两个函数，都实现了<strong>push()</strong>和<strong>pop()</strong><br><strong>AppContext</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppContext</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""The application context binds an application object implicitly</span></span><br><span class="line"><span class="string">    to the current thread or greenlet, similar to how the</span></span><br><span class="line"><span class="string">    :class:`RequestContext` binds request information.  The application</span></span><br><span class="line"><span class="string">    context is also implicitly created if a request context is created</span></span><br><span class="line"><span class="string">    but the application is not on top of the individual application</span></span><br><span class="line"><span class="string">    context.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, app)</span>:</span></span><br><span class="line">        self.app = app</span><br><span class="line">        self.url_adapter = app.create_url_adapter(<span class="keyword">None</span>)</span><br><span class="line">        self.g = app.app_ctx_globals_class()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Like request context, app contexts can be pushed multiple times</span></span><br><span class="line">        <span class="comment"># but there a basic "refcount" is enough to track them.</span></span><br><span class="line">        self._refcnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Binds the app context to the current context."""</span></span><br><span class="line">        self._refcnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(sys, <span class="string">'exc_clear'</span>):</span><br><span class="line">            sys.exc_clear()</span><br><span class="line">        _app_ctx_stack.push(self)</span><br><span class="line">        appcontext_pushed.send(self.app)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self, exc=_sentinel)</span>:</span></span><br><span class="line">        <span class="string">"""Pops the app context."""</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._refcnt -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self._refcnt &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> exc <span class="keyword">is</span> _sentinel:</span><br><span class="line">                    exc = sys.exc_info()[<span class="number">1</span>]</span><br><span class="line">                self.app.do_teardown_appcontext(exc)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            rv = _app_ctx_stack.pop()</span><br><span class="line">        <span class="keyword">assert</span> rv <span class="keyword">is</span> self, <span class="string">'Popped wrong app context.  (%r instead of %r)'</span> \</span><br><span class="line">            % (rv, self)</span><br><span class="line">        appcontext_popped.send(self.app)</span><br></pre></td></tr></table></figure></p><p>flask在RequestContext入栈前会检查另外一个AppContext的栈的情况，如果栈顶元素为空或者不是当前对象，就会把AppContext推入栈中，然后RequestContext才进栈。<br><strong>LocalStack作用是线程隔离</strong><br><strong>LocalProxy 的作用就是可以根据线程/协程返回对应当前协程/线程的代理对象</strong>，也就是说</p><ul><li>线程 A 往 LocalStack中塞入 A</li><li>线程 B 往 LocalStack 中塞入 B</li></ul><p>无论在是什么地方，调用LocalProxy，</p><p><strong>线程 A 永远取到得是 A，线程 B 取到得永远是 B</strong></p><p>有关Local、LocalStack的详解可以参考：<a href="http://python.jobbole.com/87738/" target="_blank" rel="noopener">http://python.jobbole.com/87738/</a></p><p>这就是在 Flask 中可以在代码中直接使用 request、current_app 这样的变量的底层原因。</p><p><strong>例如：</strong><br>过程就好比导游与游客。</p><ul><li>导游-&gt;AppContext</li><li>游客-&gt;RequestContext</li><li>工作-&gt;push</li><li>消费-&gt;push</li><li>向导-&gt;current_app</li><li>游玩-&gt;request</li><li>旅程-&gt;LocalStack</li></ul><p>每批游客都需要一位导游作为这批游客的专属向导，人生地不熟如果没有向导就麻烦了，因此游客开始去游玩前需要有导游带团。在这旅程中，导游和游客虽然分别是工作和消费，但导游（对象:栈顶元素）的任务就是给游客提供向导（属性:app），不提供其他服务，而游客负责游玩。当游客结束这旅程的同时导游的任务也完成（两个栈中的元素会被弹出）了。</p><h1 id="手动AppContext进栈"><a href="#手动AppContext进栈" class="headerlink" title="手动AppContext进栈"></a>手动AppContext进栈</h1><p><strong>代码：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, current_app</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># flask应用实例入栈</span></span><br><span class="line">ctx = app.app_context()</span><br><span class="line">ctx.push()</span><br><span class="line">a = current_app</span><br><span class="line">ctx.pop()</span><br></pre></td></tr></table></figure><p><strong>运行：</strong><br><img src="https://img-blog.csdn.net/20180610191854274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br><strong>注意：</strong><br>但最终<strong>current_app</strong>得到的栈顶元素不是应用上下文，而是flask的应用实例对象!<br>F12进入查看源码<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">current_app = LocalProxy(_find_app)</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">查看**_find_app**函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_find_app</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    top = _app_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top is <span class="symbol">None:</span></span><br><span class="line">        raise RuntimeError(_app_ctx_err_msg)</span><br><span class="line">    <span class="keyword">return</span> top.app</span><br></pre></td></tr></table></figure></p><p>可以发现最后返回的是top对象中的app。<br>reques和session同理，不过传多一个字符串进行查找。</p><h2 id="flask自动入栈"><a href="#flask自动入栈" class="headerlink" title="flask自动入栈"></a>flask自动入栈</h2><p>如果是在一个请求中直接使用current_app对象是不用手动把AppContext推入栈中的。如之前所说RequestContext入栈前会检查另外一个AppContext的栈的情况，这个操作会由flask帮你完成。</p><h2 id="手动进栈存在的价值"><a href="#手动进栈存在的价值" class="headerlink" title="手动进栈存在的价值"></a>手动进栈存在的价值</h2><p>单元测试不在reques请求环境中执行，需要手动AppContext进栈。离线应用。例如待会介绍的异步邮箱例子。</p><h1 id="flask上下文与with语句"><a href="#flask上下文与with语句" class="headerlink" title="flask上下文与with语句"></a>flask上下文与with语句</h1><p>可以使用with 来实现自动入栈和出栈，比上面手动push、pop的更优雅，因为在AppContext中已实现两个特殊方法<strong>enter</strong>、<strong>exit</strong>，也被称为“魔法方法”，凡是实现了这两个特殊方法的对象都可以被with所使用。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.push()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(<span class="keyword">self</span>, exc_type, exc_value, tb)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.pop(exc_value)</span><br></pre></td></tr></table></figure></p><p>python <strong>with</strong>的使用这里不详细讨论,在flask中注意的是：</p><ul><li>实现了上下文协议的对象使用with</li><li>with被称做上下文管理器</li><li>只要实现<strong><strong>enter</strong></strong>、<strong><strong>exit</strong></strong>就是实现上下文协议</li><li>上下文表达式（app.app_context()）必须返回一个上下文管理器（AppContext）</li><li><strong><strong>exit</strong></strong>最后三个参数记录发生异常时的信息，<strong><strong>exit</strong></strong>返回bool类型，返回true表示正常，false会抛出异常，没有返回值默认为false</li></ul><p><strong>代码：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from flask <span class="built_in">import</span> Flask, current_app</span><br><span class="line"></span><br><span class="line"><span class="attr">app</span> = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> app.app_context():</span><br><span class="line">    <span class="attr">a</span> = current_app</span><br></pre></td></tr></table></figure><p><strong>运行：</strong><br><img src="https://img-blog.csdn.net/20180610192248712?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>上图中全局变量a在with的作用域中的值为flask应用的实例对象<strong><strong>main</strong></strong>,当with关闭后就变成了<strong>LocalProxy unbound</strong></p><h1 id="flask中实际应用"><a href="#flask中实际应用" class="headerlink" title="flask中实际应用"></a>flask中实际应用</h1><p>发送密码重置电子邮件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> render_template</span><br><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_password_reset_email</span><span class="params">(user)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">令牌，生成密码重置电子邮件</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">    token = user.get_reset_password_token()</span><br><span class="line">    <span class="comment"># 调用email.py中的send_email函数</span></span><br><span class="line">    send_email(<span class="string">'[Microblog] Reset Your Password'</span>,</span><br><span class="line">               sender=app.config[<span class="string">'ADMINS'</span>][<span class="number">0</span>],</span><br><span class="line">               recipients=[user.email],</span><br><span class="line">               text_body=render_template(<span class="string">'email/reset_password.txt'</span>,</span><br><span class="line">                                         user=user, token=token),</span><br><span class="line">               html_body=render_template(<span class="string">'email/reset_password.html'</span>,</span><br><span class="line">                                         user=user, token=token))</span><br></pre></td></tr></table></figure></p><h2 id="异步电子邮件"><a href="#异步电子邮件" class="headerlink" title="异步电子邮件"></a>异步电子邮件</h2><p>email.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> current_app</span><br><span class="line"><span class="keyword">from</span> flask_mail <span class="keyword">import</span> Message</span><br><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> mail</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_async_email</span><span class="params">(app, msg)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> app.app_context():</span><br><span class="line">        mail.send(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(subject, sender, recipients, text_body, html_body,</span></span></span><br><span class="line"><span class="function"><span class="params">               attachments=None, sync=False)</span>:</span></span><br><span class="line">    msg = Message(subject, sender=sender, recipients=recipients)</span><br><span class="line">    msg.body = text_body</span><br><span class="line">    msg.html = html_body</span><br><span class="line">    <span class="keyword">if</span> attachments: <span class="comment"># 附件</span></span><br><span class="line">        <span class="keyword">for</span> attachment <span class="keyword">in</span> attachments:</span><br><span class="line">            msg.attach(*attachment)</span><br><span class="line">    <span class="keyword">if</span> sync: <span class="comment"># 是否异步</span></span><br><span class="line">        mail.send(msg)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        Thread(target=send_async_email,</span><br><span class="line">            args=(current_app._get_current_object(), msg)).start()</span><br></pre></td></tr></table></figure><h3 id="1-send-async-email"><a href="#1-send-async-email" class="headerlink" title="1. send_async_email()"></a>1. send_async_email()</h3><p><strong>mail.send()</strong>方法需要访问电子邮件服务器的配置值，而这必须通过访问应用属性的方式来实现。 使用<strong>with app.app_context()</strong>调用创建的应用上下文使得应用实例可以通过来自Flask的<strong>current_app</strong>变量来进行访问。</p><h3 id="2-send-email-："><a href="#2-send-email-：" class="headerlink" title="2. send_email()："></a>2. send_email()：</h3><p>在<strong>send_email()</strong>函数中，应用实例作为参数传递给后台线程，后台线程将发送电子邮件而不阻塞主应用程序。在作为后台线程运行的<strong>send_async_email()</strong>函数中直接使用<strong>current_app</strong>将不会奏效，因为<strong>current_app</strong>是一个与处理客户端请求的线程绑定的上下文感知变量。在另一个线程中，<strong>current_app</strong>没有赋值。直接将<strong>current_app</strong>作为参数传递给线程对象也不会有效，因为<strong>current_app</strong>实际上是一个<strong>代理对象</strong>，它被动态地映射到应用实例。因此，传递代理对象与直接在线程中使用<strong>current_app</strong>相同。我需要做的是访问存储在代理对象中的实际应用程序实例，并将其作为app参数传递。 <strong>current_app._get_current_object()</strong>表达式从代理对象中提取实际的应用实例，所以它就是我作为参数传递给线程的。</p><h2 id="current-app-get-current-object"><a href="#current-app-get-current-object" class="headerlink" title="current_app._get_current_object()"></a>current_app._get_current_object()</h2><p>作用是<strong>获取本线程的应用实例</strong>以作为参数传递给其他线程使用，应用实例就是<strong>_find_app</strong>中返回的<strong>top.app</strong></p><p>因为current_app = LocalProxy(_find_app)中LocalProxy作用是获得线程隔离对象，在上面<strong>详解flask上下文与出入栈</strong>有说到</p><p>所以哪怕其他线程获得了current_app这个变量，他的线程隔离中也没有任何东西</p><p>而把本线程中的属性传递给其他线程却不关线程隔离的事，所以其他线程可以使用应用实例</p><p>代码：<br><img src="https://img-blog.csdn.net/20180729123834612?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>原本是要调用<strong>_find_app</strong>才得到<strong>top.app</strong>的，现在通过<strong>current_app._get_current_object()</strong>不经过<strong>_find_app</strong>也可以获得，无关线程隔离</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>以线程ID号作为key的字典-&gt;Local-&gt;LocalStack</li><li>AppContext RequestContext -&gt; LocalStack</li><li>Flask -&gt; AppContext Request -&gt; RequestContext</li><li>(LocalStack.top = AppContext top.app=Flask) -&gt; current_app</li><li>(LocalStack.top = RequestContext top.request=Request) -&gt;  request</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;加深了对于Flask中current_app的理解，弥补了Miguel Grinberg的教程略过的知识点。&lt;br&gt;
    
    </summary>
    
      <category term="Flask" scheme="http://itfriends.xyz/categories/Flask/"/>
    
    
      <category term="Flask" scheme="http://itfriends.xyz/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之NexT主题 icon一直显示默认样式</title>
    <link href="http://itfriends.xyz/2018/06/09/next%E4%B9%8Bicon/"/>
    <id>http://itfriends.xyz/2018/06/09/next之icon/</id>
    <published>2018-06-09T13:51:52.000Z</published>
    <updated>2018-06-11T15:28:00.746Z</updated>
    
    <content type="html"><![CDATA[<p>今天配置了一下午的next主题，也遇到了一些问题，主要还是官方教程和网上的教程贴都是按照以前的next版本的，印象深刻的就是icon。<br><a id="more"></a><br>无论网上还是官方文档有关于icon的图标设置都差不多如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  GitHub: https://github.com/yourname</span><br><span class="line">  邮箱: mailto:test@gamil.com</span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  icons_only: false</span><br><span class="line">  transition: false</span><br><span class="line">  GitHub: github</span><br><span class="line">  邮箱: envelope</span><br></pre></td></tr></table></figure></p><p>但在最新的next中这样配置会变成这样子：<br><img src="next之icon/1.png" alt=""><br>并且如果 <em>icons_only: true</em> 的话也会变成这样<br><img src="next之icon/2.png" alt=""><br>正确配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  GitHub: https://github.com/yourname || github</span><br><span class="line">  邮箱: mailto:test@gamil.com || envelope</span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  icons_only: false</span><br><span class="line">  transition: false</span><br></pre></td></tr></table></figure></p><p><img src="next之icon/3.png" alt=""></p><p><img src="next之icon/4.png" alt=""><br>我还是在网上查找后才解决，这次附上了图。<br>其实<strong>主题配置文件</strong>_config.yml已经有注释的了，但新手刚刚接触的话可能直接按照官方或者网上教程来，而忽视了注释。<br>嗯。。。hexo的上传图片也是个不太舒服的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天配置了一下午的next主题，也遇到了一些问题，主要还是官方教程和网上的教程贴都是按照以前的next版本的，印象深刻的就是icon。&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://itfriends.xyz/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://itfriends.xyz/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Python sort与sorted</title>
    <link href="http://itfriends.xyz/2018/06/09/Python%20sort%E4%B8%8Esorted/"/>
    <id>http://itfriends.xyz/2018/06/09/Python sort与sorted/</id>
    <published>2018-06-08T16:30:47.040Z</published>
    <updated>2018-06-09T07:53:10.742Z</updated>
    
    <content type="html"><![CDATA[<p>了解sort与sorted的排序<br><a id="more"></a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong>sort语法：</strong><br>python2:<br>iterable.sort(cmp[, key[, reverse]])<br>python3:<br>iterable.sort(<em>, key=None, reverse=False)<br><strong>sorted 语法：</strong><br>python2:<br>sorted(iterable[, cmp[, key[, reverse]]])<br>python3:<br>sorted(iterable, </em>, key=None, reverse=False)</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><strong>iterable</strong> – 可迭代对象。<br><strong>cmp</strong>(python3中已经取消) – 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。<br><strong>key</strong> – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。在对一些字符串排序时，可以用key=str.lower来忽略大小写的排序，或者是用key=len进行基于字符串长度的排序。<br><strong>reverse</strong>–排序规则. reverse = True 或者 reverse = False(默认)。<br>（cmp和key可以使用lambda表达式）</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>sort是成员函数，sorted是built-in内建函数（被解释器所调用）<br>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。<br>list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作</p><p><strong>注意</strong>：<br>在Python3版本中，sort和sorted已经取消了cmp，也就是说安装原先的方法已经无法满足根据两个参数的比较来排序的需求，<br>但可以使用cmp_to_key</p><p><strong>例1：</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; students = [(<span class="string">'danny'</span>, <span class="string">'male'</span>, <span class="number">15</span>), (<span class="string">'Tom'</span>, <span class="string">'male'</span>, <span class="number">12</span>), (<span class="string">'Jerry'</span>,<span class="string">'female'</span>, <span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(students,key=lambda <span class="symbol">s:</span> s[<span class="number">2</span>]) <span class="comment">#按照年龄来排序</span></span><br><span class="line">[(<span class="string">'Jerry'</span>, <span class="string">'female'</span>, <span class="number">10</span>), (<span class="string">'Tom'</span>, <span class="string">'male'</span>, <span class="number">12</span>), (<span class="string">'danny'</span>, <span class="string">'male'</span>, <span class="number">15</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; students<span class="comment">#使用sorted，原来的列表没有变化</span></span><br><span class="line">[(<span class="string">'danny'</span>, <span class="string">'male'</span>, <span class="number">15</span>), (<span class="string">'Tom'</span>, <span class="string">'male'</span>, <span class="number">12</span>), (<span class="string">'Jerry'</span>, <span class="string">'female'</span>, <span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; students.sort(key=lambda <span class="symbol">s:</span> s[<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; students<span class="comment">#使用了元素的函数sort自身发生了改变</span></span><br><span class="line">[(<span class="string">'Jerry'</span>, <span class="string">'female'</span>, <span class="number">10</span>), (<span class="string">'Tom'</span>, <span class="string">'male'</span>, <span class="number">12</span>), (<span class="string">'danny'</span>, <span class="string">'male'</span>, <span class="number">15</span>)]</span><br></pre></td></tr></table></figure><p><strong>例2：</strong><br>字符串排序，排序规则：小写-大写-奇数-偶数</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = 'asdf<span class="number">234</span>GDSdsf<span class="number">23</span>'</span><br><span class="line">&gt;&gt;&gt; print(<span class="string">""</span>.join(sorted(s, key=lambda <span class="keyword">x</span>: (<span class="keyword">x</span>.isdigit(),<span class="keyword">x</span>.isdigit() <span class="keyword">and</span> int(<span class="keyword">x</span>) <span class="symbol">%2</span> == <span class="number">0</span>,<span class="keyword">x</span>.isupper(),<span class="keyword">x</span>))))</span><br><span class="line">addffssDGS<span class="number">33224</span></span><br></pre></td></tr></table></figure><p>1.x.isdigit()检测字符串是否只由数字组成，排序把数字放在右边,字母放在左边.<br>2.x.isdigit() and int(x) % 2 == 0的作用是保证奇数在右，偶数在左。<br>3.x.isupper()的作用是在前面基础上,保证字母小写在右大写在左.<br>4.最后的x表示在前面基础上,对所有类别数字或字母排序。<br><strong>例3：</strong><br>要求1.正数在前负数在后 2.整数从小到大 3.负数从大到小</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list_a=[7, <span class="string">-8</span>, 5, 4, 0, <span class="string">-2</span>, <span class="string">-5</span>]</span><br><span class="line">&gt;&gt;&gt; sorted(list_a,key=lambda x:(x&lt;0,abs(x)))</span><br><span class="line">[0, 4, 5, 7, <span class="string">-2</span>, <span class="string">-5</span>, <span class="string">-8</span>]</span><br><span class="line">&gt;&gt;&gt; list_a</span><br><span class="line">[7, <span class="string">-8</span>, 5, 4, 0, <span class="string">-2</span>, <span class="string">-5</span>]</span><br><span class="line">&gt;&gt;&gt; list_a.sort(key=lambda x:(x&lt;0,abs(x)))</span><br><span class="line">&gt;&gt;&gt; list_a</span><br><span class="line">[0, 4, 5, 7, <span class="string">-2</span>, <span class="string">-5</span>, <span class="string">-8</span>]</span><br></pre></td></tr></table></figure><p>先按照正负排先后，再按照大小排先后。</p><p><strong>例子4使用cmp：</strong><br>来源牛客网<br>编程题目原地址</p><p><a href="https://www.nowcoder.com/practice/a6a656249f404eb498d16b2f8eaa2c60?tpId=85&amp;&amp;tqId=29898&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/a6a656249f404eb498d16b2f8eaa2c60?tpId=85&amp;&amp;tqId=29898&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/2017test/question-ranking</a></p><p>题目内容如下</p><p>设有n个正整数，将他们连接成一排，组成一个最大的多位整数。<br>如:n=3时，3个整数13,312,343,连成的最大整数为34331213。<br>如:n=4时,4个整数7,13,4,246连接成的最大整数为7424613。<br>输入描述:<br>有多组测试样例，每组测试样例包含两行，第一行为一个整数N（N&lt;=100），第二行包含N个数(每个数不超过1000，空格分开)。<br>输出描述:<br>每组数据输出一个表示最大的整数。<br>示例1<br><strong>输入</strong></p><p>2<br>12 123<br>4<br>7 13 4 246<br><strong>输出</strong></p><p>12312<br>7424613</p><p><strong>python2：</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def cmp(<span class="keyword">a</span>, <span class="keyword">b</span>):  </span><br><span class="line">    <span class="keyword">ab</span> = <span class="keyword">int</span>(<span class="keyword">a</span>+<span class="keyword">b</span>)  </span><br><span class="line">    <span class="keyword">ba</span> = <span class="keyword">int</span>(<span class="keyword">b</span>+<span class="keyword">a</span>)  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> <span class="keyword">ab</span> &gt; <span class="keyword">ba</span> <span class="keyword">else</span> -<span class="number">1</span>  </span><br><span class="line">num = <span class="built_in">input</span>()  </span><br><span class="line"><span class="keyword">l</span>=raw_input().<span class="keyword">split</span>(<span class="string">' '</span>)  </span><br><span class="line"><span class="keyword">l</span>.<span class="keyword">sort</span>(cmp, <span class="built_in">reverse</span>=True)  </span><br><span class="line"><span class="keyword">print</span> <span class="keyword">int</span>(<span class="string">''</span>.<span class="keyword">join</span>(<span class="keyword">l</span>))</span><br></pre></td></tr></table></figure><p><strong>python3：</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from functools import cmp_to_key #导入使用cmp_to_key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def cmp(<span class="keyword">a</span>, <span class="keyword">b</span>):  </span><br><span class="line">    <span class="keyword">ab</span> = <span class="keyword">int</span>(<span class="keyword">a</span>+<span class="keyword">b</span>)  </span><br><span class="line">    <span class="keyword">ba</span> = <span class="keyword">int</span>(<span class="keyword">b</span>+<span class="keyword">a</span>)  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> <span class="keyword">ab</span> &gt; <span class="keyword">ba</span> <span class="keyword">else</span> -<span class="number">1</span>  </span><br><span class="line">num = <span class="built_in">input</span>()  </span><br><span class="line"><span class="keyword">l</span>=<span class="built_in">input</span>().<span class="keyword">split</span>(<span class="string">' '</span>)  #python3中把python2的row_input(str)和iuput(<span class="keyword">int</span>)结合到inptu(str)一起</span><br><span class="line"><span class="keyword">l</span>.<span class="keyword">sort</span>(key=cmp_to_key(cmp), <span class="built_in">reverse</span>=True)  </span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">int</span>(<span class="string">''</span>.<span class="keyword">join</span>(<span class="keyword">l</span>)))</span><br></pre></td></tr></table></figure><p>python3中sort和sorted取消了对cmp的支持，并且key接受一个函数，这个函数只接受一个元素，而当需要两个元素来进行比较时可以使用functools.cmp_to_key。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>key 和 reverse 比一个等价的 cmp 函数处理速度要快。这是因为对于每个列表元素，cmp 都会被调用多次，而 key 和 reverse 只被调用一次<br>可选参数key还可以在内置函数min()和max()中起作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解sort与sorted的排序&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://itfriends.xyz/categories/Python/"/>
    
    
      <category term="Python" scheme="http://itfriends.xyz/tags/Python/"/>
    
  </entry>
  
</feed>
